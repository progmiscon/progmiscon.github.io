{
    "componentChunkName": "component---src-templates-concept-js",
    "path": "/concepts/method/Java/",
    "result": {"data":{"concept":{"slug":"concepts/Method","frontmatter":{"wikipedia":"Method_(computer_programming)","shortDescription":"A method is a function that is a member of a class and may operate on an object.","relatedConcepts":["Function","Member","Class","Object"],"text":[{"id":"tapl","sections":["18","19"]}]}},"misconceptions":{"totalCount":46,"edges":[{"node":{"fields":{"slug":"/misconceptions/Java/AddMemberAtRuntime/","name":"AddMemberAtRuntime","pl":"Java"},"frontmatter":{"shortDescription":"Set of class members can change at runtime"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ArrayHasLengthMethod/","name":"ArrayHasLengthMethod","pl":"Java"},"frontmatter":{"shortDescription":"To get the length of an array, one needs to call its length method"}}},{"node":{"fields":{"slug":"/misconceptions/Java/BaseCaseNotNeeded/","name":"BaseCaseNotNeeded","pl":"Java"},"frontmatter":{"shortDescription":"Recursive computations do not necessarily need a base case"}}},{"node":{"fields":{"slug":"/misconceptions/Java/BaseCaseSelfRecursive/","name":"BaseCaseSelfRecursive","pl":"Java"},"frontmatter":{"shortDescription":"The base case of a structural recursion consists of a recursive self-call"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CallNotStaticallyChecked/","name":"CallNotStaticallyChecked","pl":"Java"},"frontmatter":{"shortDescription":"A method invocation on a reference of a type that does not have that method won't compile"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CallOnPrimitive/","name":"CallOnPrimitive","pl":"Java"},"frontmatter":{"shortDescription":"One can invoke a method on primitive values"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CallRequiresVariable/","name":"CallRequiresVariable","pl":"Java"},"frontmatter":{"shortDescription":"One needs a variable to invoke a method"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CallWithoutFrame/","name":"CallWithoutFrame","pl":"Java"},"frontmatter":{"shortDescription":"A method invocation does not necessarily allocate a stack frame"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CallerFrameContainsCalleeFormal/","name":"CallerFrameContainsCalleeFormal","pl":"Java"},"frontmatter":{"shortDescription":"Stack frame of caller includes variables for callee's formal parameters"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CannotChainMemberAccesses/","name":"CannotChainMemberAccesses","pl":"Java"},"frontmatter":{"shortDescription":"Member accesses cannot be chained together"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CannotChainMemberToConstructor/","name":"CannotChainMemberToConstructor","pl":"Java"},"frontmatter":{"shortDescription":"Method calls or field accesses cannot be chained to a constructor invocation"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ChainedMethodsNotCalledFromOutside/","name":"ChainedMethodsNotCalledFromOutside","pl":"Java"},"frontmatter":{"shortDescription":"Chained methods are all called on the object at the beginning of the chain"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ConcreteClassMustOverride/","name":"ConcreteClassMustOverride","pl":"Java"},"frontmatter":{"shortDescription":"A concrete class needs to implement all abstract methods and override all concrete methods declared in its abstract superclasses"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementClassAbstract/","name":"ConcreteClassOnlyImplementClassAbstract","pl":"Java"},"frontmatter":{"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from abstract superclasses"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementDirectAbstract/","name":"ConcreteClassOnlyImplementDirectAbstract","pl":"Java"},"frontmatter":{"shortDescription":"A concrete class only needs to implement abstract methods declared in its direct supertypes"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementInterfaceAbstract/","name":"ConcreteClassOnlyImplementInterfaceAbstract","pl":"Java"},"frontmatter":{"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from interfaces"}}},{"node":{"fields":{"slug":"/misconceptions/Java/DeferredReturn/","name":"DeferredReturn","pl":"Java"},"frontmatter":{"shortDescription":"A return statement in the middle of a method doesn't return immediately"}}},{"node":{"fields":{"slug":"/misconceptions/Java/EqualsComparesReferences/","name":"EqualsComparesReferences","pl":"Java"},"frontmatter":{"shortDescription":"o.equals(p) compares the references stored in the variables o and p"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ImmutableRequiresFinalParameters/","name":"ImmutableRequiresFinalParameters","pl":"Java"},"frontmatter":{"shortDescription":"Immutable classes need final constructor/method parameters"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ImplicitInterfaceImplementation/","name":"ImplicitInterfaceImplementation","pl":"Java"},"frontmatter":{"shortDescription":"Java implicitly produces implementations of any methods a class inherits from the interfaces it implements"}}},{"node":{"fields":{"slug":"/misconceptions/Java/MethodAsField/","name":"MethodAsField","pl":"Java"},"frontmatter":{"shortDescription":"Each object contains its own special fields for all of its methods"}}},{"node":{"fields":{"slug":"/misconceptions/Java/MethodWithoutReturnType/","name":"MethodWithoutReturnType","pl":"Java"},"frontmatter":{"shortDescription":"A method declaration does not need to include a return type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/MethodsWithoutClass/","name":"MethodsWithoutClass","pl":"Java"},"frontmatter":{"shortDescription":"Methods can be defined outside a class"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoCallOnStringLiteral/","name":"NoCallOnStringLiteral","pl":"Java"},"frontmatter":{"shortDescription":"One cannot invoke methods on String literals"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoInsideMethodCallInConstructor/","name":"NoInsideMethodCallInConstructor","pl":"Java"},"frontmatter":{"shortDescription":"It is foirbidden to call other methods on the same object while inside its constructor"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoMethodInheritance/","name":"NoMethodInheritance","pl":"Java"},"frontmatter":{"shortDescription":"Subclasses inherit fields but not methods"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoStringToString/","name":"NoStringToString","pl":"Java"},"frontmatter":{"shortDescription":"One cannot invoke toString() on a String"}}},{"node":{"fields":{"slug":"/misconceptions/Java/OutsideInMethodNesting/","name":"OutsideInMethodNesting","pl":"Java"},"frontmatter":{"shortDescription":"Nested method calls are invoked outside in"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument","pl":"Java"},"frontmatter":{"shortDescription":"() are optional for method calls without arguments"}}},{"node":{"fields":{"slug":"/misconceptions/Java/PrivateAccessibleInSubclass/","name":"PrivateAccessibleInSubclass","pl":"Java"},"frontmatter":{"shortDescription":"Private members of a superclass are accessible from a subclass"}}},{"node":{"fields":{"slug":"/misconceptions/Java/RecursiveMethodImpliesRecursiveType/","name":"RecursiveMethodImpliesRecursiveType","pl":"Java"},"frontmatter":{"shortDescription":"A class with a recursive method represents part of a recursive data structure"}}},{"node":{"fields":{"slug":"/misconceptions/Java/RecursiveMethodNeedsIfElse/","name":"RecursiveMethodNeedsIfElse","pl":"Java"},"frontmatter":{"shortDescription":"A recursive method needs to contain an if-else statement"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ReturnCall/","name":"ReturnCall","pl":"Java"},"frontmatter":{"shortDescription":"Return statements need () around the return value"}}},{"node":{"fields":{"slug":"/misconceptions/Java/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Java"},"frontmatter":{"shortDescription":"Chained accesses are invoked from right to left"}}},{"node":{"fields":{"slug":"/misconceptions/Java/StackTraceIsCallHistory/","name":"StackTraceIsCallHistory","pl":"Java"},"frontmatter":{"shortDescription":"A stack trace is the sequence of previously called methods"}}},{"node":{"fields":{"slug":"/misconceptions/Java/StaticCallPolymorphic/","name":"StaticCallPolymorphic","pl":"Java"},"frontmatter":{"shortDescription":"A static method call is dispatched polymorphically at runtime based on the argument types"}}},{"node":{"fields":{"slug":"/misconceptions/Java/StaticDispatch/","name":"StaticDispatch","pl":"Java"},"frontmatter":{"shortDescription":"The method to be called is determined by the static type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/StringLengthField/","name":"StringLengthField","pl":"Java"},"frontmatter":{"shortDescription":"One can know the length of a String object by accessing its length field"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ThisExistsInStaticMethod/","name":"ThisExistsInStaticMethod","pl":"Java"},"frontmatter":{"shortDescription":"this is a local variable, also in static methods"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ToStringPrints/","name":"ToStringPrints","pl":"Java"},"frontmatter":{"shortDescription":"Invoking toString() prints something"}}},{"node":{"fields":{"slug":"/misconceptions/Java/UseOfSelfTypeImpliesRecursiveType/","name":"UseOfSelfTypeImpliesRecursiveType","pl":"Java"},"frontmatter":{"shortDescription":"If a class has a method that has a local variable, parameter, or return value with the class as its type, the class is a recursive type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/VoidMethodNotRecursive/","name":"VoidMethodNotRecursive","pl":"Java"},"frontmatter":{"shortDescription":"A method with void return type can't be recursive"}}},{"node":{"fields":{"slug":"/misconceptions/Java/VoidMethodReturnsValue/","name":"VoidMethodReturnsValue","pl":"Java"},"frontmatter":{"shortDescription":"A method with void return type can return a value"}}},{"node":{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeAccesses/","name":"CannotChainAttributeAccesses","pl":"Python"},"frontmatter":{"shortDescription":"Attribute accesses cannot be chained together"}}},{"node":{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeToObjectInstantiation/","name":"CannotChainAttributeToObjectInstantiation","pl":"Python"},"frontmatter":{"shortDescription":"Method calls, and attribute accesses in general, cannot be chained to a constructor invocation."}}},{"node":{"fields":{"slug":"/misconceptions/Python/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Python"},"frontmatter":{"shortDescription":"Chained accesses are invoked from right to left"}}}]},"pls":{"edges":[{"node":{"frontmatter":{"id":"Java"}}},{"node":{"frontmatter":{"id":"JavaScript"}}},{"node":{"frontmatter":{"id":"Python"}}},{"node":{"frontmatter":{"id":"Scratch"}}}]},"textbooks":{"nodes":[{"frontmatter":{"title":"Category Theory for Programmers","home":"https://github.com/hmemcpy/milewski-ctfp-pdf","author":"Bartosz Milewski"},"parent":{"name":"ctp"}},{"frontmatter":{"title":"Compilers: Principles, Techniques, and Tools","home":"https://suif.stanford.edu/dragonbook/","author":"Alfred Aho, Ravi Sethi, Jeffrey Ullman, Monica S. Lam"},"parent":{"name":"dragon"}},{"frontmatter":{"title":"nLab","home":"https://ncatlab.org/nlab/show/HomePage","author":"David Corfield, David Roberts, Mike Shulman, Toby Bartels, Todd Trimble"},"parent":{"name":"nlab"}},{"frontmatter":{"title":"Objects-First with Java","home":"https://www.bluej.org/objects-first/","author":"David J. Barnes & Michael Kölling"},"parent":{"name":"ofj6"}},{"frontmatter":{"title":"Sprechen Sie Java","home":"https://ssw.jku.at/Misc/JavaBuch/","author":"Hanspeter Mössenböck"},"parent":{"name":"ssj4"}},{"frontmatter":{"title":"Types and Programming Languages","home":"https://www.cis.upenn.edu/~bcpierce/tapl/","author":"Benjamin C. Pierce"},"parent":{"name":"tapl"}}]}},"pageContext":{"concept":"Method","slug":"concepts/Method","wikipediaSummary":"","pl":"Java"}},
    "staticQueryHashes": ["3649515864","4169798128"]}