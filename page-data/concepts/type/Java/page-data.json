{
    "componentChunkName": "component---src-templates-concept-js",
    "path": "/concepts/type/Java/",
    "result": {"data":{"concept":{"slug":"concepts/Type","frontmatter":{"wikipedia":"Type_system","shortDescription":"A type is a set of values supporting a certain set of operations.","relatedConcepts":["Value","Class"],"text":[{"id":"nlab","sections":["type theory"]},{"id":"tapl","sections":["1"]}]}},"misconceptions":{"totalCount":37,"edges":[{"node":{"fields":{"slug":"/misconceptions/Java/ArrayElementTypeRepeats/","name":"ArrayElementTypeRepeats","pl":"Java"},"frontmatter":{"shortDescription":"The type of a multi-dimensional array is written as T[] T[] T[]"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ArrayElementsUntyped/","name":"ArrayElementsUntyped","pl":"Java"},"frontmatter":{"shortDescription":"Elements of arrays are untyped"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ArrayLengthPartOfType/","name":"ArrayLengthPartOfType","pl":"Java"},"frontmatter":{"shortDescription":"The length of an array is part of its type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ArrayRankNotPartOfType/","name":"ArrayRankNotPartOfType","pl":"Java"},"frontmatter":{"shortDescription":"The rank of an array is not part of its type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CharNotNumeric/","name":"CharNotNumeric","pl":"Java"},"frontmatter":{"shortDescription":"Char is not a numeric type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/CompositeExpressionsUntyped/","name":"CompositeExpressionsUntyped","pl":"Java"},"frontmatter":{"shortDescription":"Expressions that consist of multiple parts have no type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ExpressionsDynamicallyTyped/","name":"ExpressionsDynamicallyTyped","pl":"Java"},"frontmatter":{"shortDescription":"One has to evaluate an expression to determine its type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/IntegerDivisionToRational/","name":"IntegerDivisionToRational","pl":"Java"},"frontmatter":{"shortDescription":"Dividing two integers can produce a rational number"}}},{"node":{"fields":{"slug":"/misconceptions/Java/LargeIntegerLong/","name":"LargeIntegerLong","pl":"Java"},"frontmatter":{"shortDescription":"Large integer numbers have type long"}}},{"node":{"fields":{"slug":"/misconceptions/Java/MethodWithoutReturnType/","name":"MethodWithoutReturnType","pl":"Java"},"frontmatter":{"shortDescription":"A method declaration does not need to include a return type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NamedTypeParameter/","name":"NamedTypeParameter","pl":"Java"},"frontmatter":{"shortDescription":"To instantiate a generic type, for each type parameter one has to specify both the name and the type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoCastIfSameSize/","name":"NoCastIfSameSize","pl":"Java"},"frontmatter":{"shortDescription":"If a variable is at least as big (bit-width) as a value, then no cast is needed to a assign the value to the variable"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoFloatLiterals/","name":"NoFloatLiterals","pl":"Java"},"frontmatter":{"shortDescription":"There are no float literals"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoImplicitWidening/","name":"NoImplicitWidening","pl":"Java"},"frontmatter":{"shortDescription":"Smaller types are never automatically converted into bigger ones without an explicit cast"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NoLongLiterals/","name":"NoLongLiterals","pl":"Java"},"frontmatter":{"shortDescription":"There are no long literals"}}},{"node":{"fields":{"slug":"/misconceptions/Java/NumericToBooleanCoercion/","name":"NumericToBooleanCoercion","pl":"Java"},"frontmatter":{"shortDescription":"Numeric types can be coerced to boolean"}}},{"node":{"fields":{"slug":"/misconceptions/Java/PrimitiveTypeParameter/","name":"PrimitiveTypeParameter","pl":"Java"},"frontmatter":{"shortDescription":"Type parameters of generic types can be instantiated with primitive types"}}},{"node":{"fields":{"slug":"/misconceptions/Java/PrimitiveVariablesDynamicallyTyped/","name":"PrimitiveVariablesDynamicallyTyped","pl":"Java"},"frontmatter":{"shortDescription":"The type of a primitive variable depends on its value"}}},{"node":{"fields":{"slug":"/misconceptions/Java/RecursiveMethodImpliesRecursiveType/","name":"RecursiveMethodImpliesRecursiveType","pl":"Java"},"frontmatter":{"shortDescription":"A class with a recursive method represents part of a recursive data structure"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ReferenceToBooleanCoercion/","name":"ReferenceToBooleanCoercion","pl":"Java"},"frontmatter":{"shortDescription":"Every reference type can be coerced to boolean"}}},{"node":{"fields":{"slug":"/misconceptions/Java/ReferenceToIntegerConversion/","name":"ReferenceToIntegerConversion","pl":"Java"},"frontmatter":{"shortDescription":"One can cast between references and ints"}}},{"node":{"fields":{"slug":"/misconceptions/Java/StaticCallPolymorphic/","name":"StaticCallPolymorphic","pl":"Java"},"frontmatter":{"shortDescription":"A static method call is dispatched polymorphically at runtime based on the argument types"}}},{"node":{"fields":{"slug":"/misconceptions/Java/SubtypeCompatibleWithSupertype/","name":"SubtypeCompatibleWithSupertype","pl":"Java"},"frontmatter":{"shortDescription":"A variable of a subtype can reference an object of a supertype"}}},{"node":{"fields":{"slug":"/misconceptions/Java/SupertypeIncompatibleWithSubtype/","name":"SupertypeIncompatibleWithSubtype","pl":"Java"},"frontmatter":{"shortDescription":"A variable of a supertype cannot reference an object of a subtype"}}},{"node":{"fields":{"slug":"/misconceptions/Java/TargetTyping/","name":"TargetTyping","pl":"Java"},"frontmatter":{"shortDescription":"The type of a numerical expression depends on the type expected by the surrounding context"}}},{"node":{"fields":{"slug":"/misconceptions/Java/UntypedVariables/","name":"UntypedVariables","pl":"Java"},"frontmatter":{"shortDescription":"Variable declarations don't need a type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/UseOfSelfTypeImpliesRecursiveType/","name":"UseOfSelfTypeImpliesRecursiveType","pl":"Java"},"frontmatter":{"shortDescription":"If a class has a method that has a local variable, parameter, or return value with the class as its type, the class is a recursive type"}}},{"node":{"fields":{"slug":"/misconceptions/Java/VoidMethodNotRecursive/","name":"VoidMethodNotRecursive","pl":"Java"},"frontmatter":{"shortDescription":"A method with void return type can't be recursive"}}},{"node":{"fields":{"slug":"/misconceptions/Java/VoidMethodReturnsValue/","name":"VoidMethodReturnsValue","pl":"Java"},"frontmatter":{"shortDescription":"A method with void return type can return a value"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/CharType/","name":"CharType","pl":"JavaScript"},"frontmatter":{"shortDescription":"A single character is of type char"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/ClassDefinesType/","name":"ClassDefinesType","pl":"JavaScript"},"frontmatter":{"shortDescription":"The type of an object is equivalent to the type defined by its class definition"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"JavaScript"},"frontmatter":{"shortDescription":"The equality operator '==' compares only the types of the operands"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/NullAndUndefinedAreTheSame/","name":"NullAndUndefinedAreTheSame","pl":"JavaScript"},"frontmatter":{"shortDescription":"The values null and undefined are the same"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/TypeofArrayIsArray/","name":"TypeofArrayIsArray","pl":"JavaScript"},"frontmatter":{"shortDescription":"The typeof operator applied on an array returns 'array'"}}},{"node":{"fields":{"slug":"/misconceptions/JavaScript/TypeofNullIsNull/","name":"TypeofNullIsNull","pl":"JavaScript"},"frontmatter":{"shortDescription":"The value null is of type 'null'"}}},{"node":{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"Scratch"},"frontmatter":{"shortDescription":"() = () compares only the types of its operands"}}},{"node":{"fields":{"slug":"/misconceptions/Scratch/ListsHomogeneous/","name":"ListsHomogeneous","pl":"Scratch"},"frontmatter":{"shortDescription":"All items in a list must have the same type"}}}]},"pls":{"edges":[{"node":{"frontmatter":{"id":"Java"}}},{"node":{"frontmatter":{"id":"JavaScript"}}},{"node":{"frontmatter":{"id":"Python"}}},{"node":{"frontmatter":{"id":"Scratch"}}}]},"textbooks":{"nodes":[{"frontmatter":{"title":"Category Theory for Programmers","home":"https://github.com/hmemcpy/milewski-ctfp-pdf","author":"Bartosz Milewski"},"parent":{"name":"ctp"}},{"frontmatter":{"title":"Compilers: Principles, Techniques, and Tools","home":"https://suif.stanford.edu/dragonbook/","author":"Alfred Aho, Ravi Sethi, Jeffrey Ullman, Monica S. Lam"},"parent":{"name":"dragon"}},{"frontmatter":{"title":"nLab","home":"https://ncatlab.org/nlab/show/HomePage","author":"David Corfield, David Roberts, Mike Shulman, Toby Bartels, Todd Trimble"},"parent":{"name":"nlab"}},{"frontmatter":{"title":"Objects-First with Java","home":"https://www.bluej.org/objects-first/","author":"David J. Barnes & Michael Kölling"},"parent":{"name":"ofj6"}},{"frontmatter":{"title":"Sprechen Sie Java","home":"https://ssw.jku.at/Misc/JavaBuch/","author":"Hanspeter Mössenböck"},"parent":{"name":"ssj4"}},{"frontmatter":{"title":"Types and Programming Languages","home":"https://www.cis.upenn.edu/~bcpierce/tapl/","author":"Benjamin C. Pierce"},"parent":{"name":"tapl"}}]}},"pageContext":{"concept":"Type","slug":"concepts/Type","wikipediaSummary":"","pl":"Java"}},
    "staticQueryHashes": ["3649515864","4169798128"]}