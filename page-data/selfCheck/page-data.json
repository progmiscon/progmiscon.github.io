{
    "componentChunkName": "component---src-pages-self-check-js",
    "path": "/selfCheck/",
    "result": {"data":{"misconceptions":{"nodes":[{"fields":{"slug":"/misconceptions/Java/AbstractClassMustImplementAbstractMethod/","name":"AbstractClassMustImplementAbstractMethod","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Inheritance","Implementation"],"shortDescription":"An abstract class must implement all abstract methods defined in its superclass","shortCorrection":"An abstract class does not need to implement all abstract methods defined in its superclass","text":null}},{"fields":{"slug":"/misconceptions/Java/AbstractClassNoImplementation/","name":"AbstractClassNoImplementation","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Inheritance"],"shortDescription":"An abstract class cannot contain implemented methods","shortCorrection":"An abstract class can also contain implemented methods","text":null}},{"fields":{"slug":"/misconceptions/Java/AddMemberAtRuntime/","name":"AddMemberAtRuntime","pl":"Java"},"frontmatter":{"status":"public","concepts":["Class","Method","Field","Allocation"],"shortDescription":"Set of class members can change at runtime","shortCorrection":"Set of class members stays fixed at runtime","text":null}},{"fields":{"slug":"/misconceptions/Java/AllClassesHaveDefaultConstructor/","name":"AllClassesHaveDefaultConstructor","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Constructor"],"shortDescription":"All classes automatically get a no-argument constructor","shortCorrection":"Only classes without constructor automatically get a no-argument constructor","text":null}},{"fields":{"slug":"/misconceptions/Java/AnyClassException/","name":"AnyClassException","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","Class"],"shortDescription":"Any class can be an exception class","shortCorrection":"Exceptions are subtypes of Throwable","text":null}},{"fields":{"slug":"/misconceptions/Java/ArithmeticPlusPrecedes/","name":"ArithmeticPlusPrecedes","pl":"Java"},"frontmatter":{"status":"public","concepts":["String","Expression","Operator","Precedence","Associativity"],"shortDescription":"Addition has higher precedence than string concatenation","shortCorrection":"Addition and string concatenation have same precedence","text":null}},{"fields":{"slug":"/misconceptions/Java/ArrayAccessWithParentheses/","name":"ArrayAccessWithParentheses","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Operator"],"shortDescription":"Parentheses are used to access an element in an array","shortCorrection":"Square brackets are used to access an element in an array","text":null}},{"fields":{"slug":"/misconceptions/Java/ArrayAllocationWithoutNew/","name":"ArrayAllocationWithoutNew","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Allocation"],"shortDescription":"Arrays are created without the new keyword","shortCorrection":"All arrays are allocated on the heap with new","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayBracketCountIsLength/","name":"ArrayBracketCountIsLength","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Allocation"],"shortDescription":"The number of brackets in an array type or an array initializer corresponds to the length of the array","shortCorrection":"The number of brackets in an array type or an array initializer corresponds to the rank of the array","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayElementTypeRepeats/","name":"ArrayElementTypeRepeats","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The type of a multi-dimensional array is written as T[] T[] T[]","shortCorrection":"The type of a multi-dimensional array is written as T[][][]","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayElementsUntyped/","name":"ArrayElementsUntyped","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"Elements of arrays are untyped","shortCorrection":"The type of an array specifies the type of the elements","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayHasLengthMethod/","name":"ArrayHasLengthMethod","pl":"Java"},"frontmatter":{"status":"public","concepts":["Array","Method","Field"],"shortDescription":"To get the length of an array, one needs to call its length method","shortCorrection":"To get the length of an array, one needs to read its length field","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayInitializerContentsInBrackets/","name":"ArrayInitializerContentsInBrackets","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Literal"],"shortDescription":"Array initializers list the elements in square brackets","shortCorrection":"Array initializers list the elements in curly braces","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayLengthCannotBeZero/","name":"ArrayLengthCannotBeZero","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"An array cannot have a length of 0 elements","shortCorrection":"An array can have a length of 0 elements","text":null}},{"fields":{"slug":"/misconceptions/Java/ArrayLengthPartOfType/","name":"ArrayLengthPartOfType","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The length of an array is part of its type","shortCorrection":"The length of an array is not part of its type","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayListIsArray/","name":"ArrayListIsArray","pl":"Java"},"frontmatter":{"status":"public","concepts":["Array","Class"],"shortDescription":"ArrayLists are arrays","shortCorrection":"ArrayLists and arrays are different things","text":[{"id":"ofj6","sections":["4","7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayRankIsLength/","name":"ArrayRankIsLength","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Array rank and array length are the same thing","shortCorrection":"Array rank and array length are different concepts","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArrayRankNotPartOfType/","name":"ArrayRankNotPartOfType","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The rank of an array is not part of its type","shortCorrection":"The rank of an array is part of its type","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/ArraysGrow/","name":"ArraysGrow","pl":"Java"},"frontmatter":{"status":"public","concepts":["Array","Allocation"],"shortDescription":"Arrays can grow dynamically","shortCorrection":"The length of an array is fixed and is determined at allocation","text":[{"id":"ofj6","sections":["7"]}]}},{"fields":{"slug":"/misconceptions/Java/AssignCompares/","name":"AssignCompares","pl":"Java"},"frontmatter":{"status":"public","concepts":["Assignment","Equality","Expression","Operator"],"shortDescription":"= compares two values","shortCorrection":"= assigns a value to a variable","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"Java"},"frontmatter":{"status":"public","concepts":["Assignment","Variable","Object","Reference"],"shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference pointing to the object","text":[{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/AssignmentNotExpression/","name":"AssignmentNotExpression","pl":"Java"},"frontmatter":{"status":"public","concepts":["Expression","Operator","Assignment"],"shortDescription":"An assignment a=b is not an expression","shortCorrection":"An assignment a=b is an expression and thus produces a value","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/BaseCaseNotNeeded/","name":"BaseCaseNotNeeded","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Recursion","Method","Conditional","Call"],"shortDescription":"Recursive computations do not necessarily need a base case","shortCorrection":"Recursive computations need a base case to terminate","text":null}},{"fields":{"slug":"/misconceptions/Java/BaseCaseSelfRecursive/","name":"BaseCaseSelfRecursive","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Recursion","Method","Call"],"shortDescription":"The base case of a structural recursion consists of a recursive self-call","shortCorrection":"The base case of a structural recursion does not perform a recursive call","text":null}},{"fields":{"slug":"/misconceptions/Java/CallNotStaticallyChecked/","name":"CallNotStaticallyChecked","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Call","Class","Subtyping"],"shortDescription":"A method invocation on a reference of a type that does not have that method won't compile","shortCorrection":"A method invocation on a reference of a type that does not have that method will compile","text":null}},{"fields":{"slug":"/misconceptions/Java/CallOnPrimitive/","name":"CallOnPrimitive","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Primitive"],"shortDescription":"One can invoke a method on primitive values","shortCorrection":"One cannot invoke methods on primitive values","text":null}},{"fields":{"slug":"/misconceptions/Java/CallRequiresVariable/","name":"CallRequiresVariable","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call"],"shortDescription":"One needs a variable to invoke a method","shortCorrection":"Methods can be invoked on expressions that evaluate to a suitable object","text":null}},{"fields":{"slug":"/misconceptions/Java/CallWithoutFrame/","name":"CallWithoutFrame","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Stack"],"shortDescription":"A method invocation does not necessarily allocate a stack frame","shortCorrection":"Each method invocation allocates a new stack frame","text":null}},{"fields":{"slug":"/misconceptions/Java/CallerFrameContainsCalleeFormal/","name":"CallerFrameContainsCalleeFormal","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Stack","Variable","Parameter"],"shortDescription":"Stack frame of caller includes variables for callee's formal parameters","shortCorrection":"Stack frame of caller does not include variables for callee's formal parameters","text":null}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberAccesses/","name":"CannotChainMemberAccesses","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator"],"shortDescription":"Member accesses cannot be chained together","shortCorrection":"Member accesses can be chained together","text":null}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberToConstructor/","name":"CannotChainMemberToConstructor","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"shortDescription":"Method calls or field accesses cannot be chained to a constructor invocation","shortCorrection":"Method calls or field accesses can be chained to a constructor invocation","text":[{"id":"ofj6","sections":["4"]}]}},{"fields":{"slug":"/misconceptions/Java/CatchAlwaysExecutes/","name":"CatchAlwaysExecutes","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Catch blocks always get executed","shortCorrection":"Catch blocks only get executed if an exception is thrown in the try block","text":null}},{"fields":{"slug":"/misconceptions/Java/CatchProvidesOptions/","name":"CatchProvidesOptions","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Only the part of a catch block necessary to fix the cause of an exception is executed","shortCorrection":"When an exception is caught, all statements in the corresponding catch block execute","text":null}},{"fields":{"slug":"/misconceptions/Java/ChainedMethodsNotCalledFromOutside/","name":"ChainedMethodsNotCalledFromOutside","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Expression","Object"],"shortDescription":"Chained methods are all called on the object at the beginning of the chain","shortCorrection":"Chained methods are called on the object that results from the previous call in the chain","text":null}},{"fields":{"slug":"/misconceptions/Java/CharNotNumeric/","name":"CharNotNumeric","pl":"Java"},"frontmatter":{"status":"public","concepts":["Number","String","Type"],"shortDescription":"Char is not a numeric type","shortCorrection":"Char is a numeric type","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ComparisonWithBooleanLiteral/","name":"ComparisonWithBooleanLiteral","pl":"Java"},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator","Equality"],"shortDescription":"To test whether an expression is true or false, one must compare it to true or to false","shortCorrection":"To test whether an expression is true or false, one can just use it","text":[{"id":"ofj6","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/CompositeExpressionsUntyped/","name":"CompositeExpressionsUntyped","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type","Expression"],"shortDescription":"Expressions that consist of multiple parts have no type","shortCorrection":"Expressions that consist of multiple parts have a type","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassMustOverride/","name":"ConcreteClassMustOverride","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Inheritance"],"shortDescription":"A concrete class needs to implement all abstract methods and override all concrete methods declared in its abstract superclasses","shortCorrection":"A concrete class does not necessarily need to override concrete methods declared in its abstract superclasses","text":null}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementClassAbstract/","name":"ConcreteClassOnlyImplementClassAbstract","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from abstract superclasses","shortCorrection":"A concrete class needs to implement both the abstract methods it inherits from abstract superclasses and those declared in the interfaces it implements","text":null}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementDirectAbstract/","name":"ConcreteClassOnlyImplementDirectAbstract","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement abstract methods declared in its direct supertypes","shortCorrection":"A concrete class needs to implement all abstract methods declared in its supertypes, both direct and indirect","text":null}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementInterfaceAbstract/","name":"ConcreteClassOnlyImplementInterfaceAbstract","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from interfaces","shortCorrection":"A concrete class needs to implement both the abstract methods it inherits from interfaces and those declared in the abstract class it extends","text":null}},{"fields":{"slug":"/misconceptions/Java/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Java"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-else is equivalent to sequence of two ifs","shortCorrection":"If-else can behave differently from sequence of two ifs","text":[{"id":"ofj6","sections":["2"]},{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorAllocates/","name":"ConstructorAllocates","pl":"Java"},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call"],"shortDescription":"The constructor allocates the object","shortCorrection":"The constructor does not allocate the object, it just initializes it","text":[{"id":"ofj6","sections":["2","3"]}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorParameterIsField/","name":"ConstructorParameterIsField","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Constructor","Parameter","Field"],"shortDescription":"Formal constructor parameters are equivalent to instance variables","shortCorrection":"Formal constructor parameters are completely separate from instance variables","text":null}},{"fields":{"slug":"/misconceptions/Java/ConstructorReturnsObject/","name":"ConstructorReturnsObject","pl":"Java"},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Return"],"shortDescription":"Constructors need to return objects","shortCorrection":"Constructors cannot return anything","text":[{"id":"ofj6","sections":["2","3"]}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorWithoutNew/","name":"ConstructorWithoutNew","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Constructor","Call","Allocation"],"shortDescription":"One can write the constructor name, without new, to instantiate a class","shortCorrection":"The constructor name needs to come after the keyword new to instantiate a class","text":null}},{"fields":{"slug":"/misconceptions/Java/ControlledLocalAccess/","name":"ControlledLocalAccess","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Scope","Lifetime","AccessModifier"],"shortDescription":"One can control access to local variables using access modifiers","shortCorrection":"One cannot control access to local variables","text":[{"id":"ofj6","sections":["6"]}]}},{"fields":{"slug":"/misconceptions/Java/DeferredReturn/","name":"DeferredReturn","pl":"Java"},"frontmatter":{"status":"public","concepts":["Return","ControlFlow","Method","Call"],"shortDescription":"A return statement in the middle of a method doesn't return immediately","shortCorrection":"A return statement immediately returns from the method","text":[{"id":"ofj6","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ElsIf/","name":"ElsIf","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"There is an elsif keyword for multi-way conditional statements","shortCorrection":"There is no special keyword for multi-way conditional statements","text":null}},{"fields":{"slug":"/misconceptions/Java/ElseAlwaysExecutes/","name":"ElseAlwaysExecutes","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"The else branch of an if-else statement always executes","shortCorrection":"The else branch of an if-else statement only executes if the condition evaluates to false","text":null}},{"fields":{"slug":"/misconceptions/Java/EqualityOperatorComparesObjectsValues/","name":"EqualityOperatorComparesObjectsValues","pl":"Java"},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Operator","Expression"],"shortDescription":"o==p compares the objects referred to by variables o and p","shortCorrection":"o==p compares the references stored in the variables o and p","text":null}},{"fields":{"slug":"/misconceptions/Java/EqualsComparesReferences/","name":"EqualsComparesReferences","pl":"Java"},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Method","Expression"],"shortDescription":"o.equals(p) compares the references stored in the variables o and p","shortCorrection":"o.equals(p) compares the objects referred to by variables o and p","text":null}},{"fields":{"slug":"/misconceptions/Java/EvaluationResultsArePrinted/","name":"EvaluationResultsArePrinted","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Evaluation","Output"],"shortDescription":"Evaluating an expression means outputting its result","shortCorrection":"Evaluating an expression produces a value, but does not output it","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ExceptionRoot/","name":"ExceptionRoot","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","Subtyping"],"shortDescription":"Exception is the top-most exception class","shortCorrection":"Throwable is the top-most exception class","text":null}},{"fields":{"slug":"/misconceptions/Java/ExpressionAssigns/","name":"ExpressionAssigns","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Expression","Assignment","Variable"],"shortDescription":"An expression that reads a variable also updates its value after the evaluation","shortCorrection":"A variable is only written using an assignment","text":null}},{"fields":{"slug":"/misconceptions/Java/ExpressionsDynamicallyTyped/","name":"ExpressionsDynamicallyTyped","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Evaluation","Expression","Value","Type"],"shortDescription":"One has to evaluate an expression to determine its type","shortCorrection":"The type of expressions is determined, without evaluation, at compile time","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/FinalReferenceImpliesImmutability/","name":"FinalReferenceImpliesImmutability","pl":"Java"},"frontmatter":{"status":"public","concepts":["Mutability","Reference"],"shortDescription":"An object referred to by a final variable is an immutable object","shortCorrection":"An object referred to by a final variable can be a mutable object","text":null}},{"fields":{"slug":"/misconceptions/Java/ForEachIteratesOverIndices/","name":"ForEachIteratesOverIndices","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Array"],"shortDescription":"An enhanced for loop iterates over the indices of an array or a collection","shortCorrection":"An enhanced for loop iterates over the elements of an array or a collection","text":null}},{"fields":{"slug":"/misconceptions/Java/ForEachTraversesRecursiveStructure/","name":"ForEachTraversesRecursiveStructure","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Recursion"],"shortDescription":"For-each loops know how to traverse any recursive data structure","shortCorrection":"For-each loops only know how to traverse arrays and Iterables","text":null}},{"fields":{"slug":"/misconceptions/Java/ForEachVariableIsElement/","name":"ForEachVariableIsElement","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Array"],"shortDescription":"One can assign to the variable of an enhanced for statement to store a value in the corresponding array or collection element","shortCorrection":"The variable of an enhanced for statement contains a copy of the value of the corresponding array or collection element","text":null}},{"fields":{"slug":"/misconceptions/Java/ForIsConditional/","name":"ForIsConditional","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of a for statement executes at most once","shortCorrection":"The body of a for statement executes repeatedly, as long as the condition holds","text":[{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/ForVariableScopeBeyondLoop/","name":"ForVariableScopeBeyondLoop","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Scope"],"shortDescription":"The scope of variables declared in a for loop header extends beyond the loop","shortCorrection":"The scope of variables declared in a for loop header is limited to the loop","text":null}},{"fields":{"slug":"/misconceptions/Java/FrameIsClassInstance/","name":"FrameIsClassInstance","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Stack","Object","Call"],"shortDescription":"A stack frame is the same as an instance of a class","shortCorrection":"Stack frames and class instances both hold variables, but they are different concepts","text":null}},{"fields":{"slug":"/misconceptions/Java/IfIsLoop/","name":"IfIsLoop","pl":"Java"},"frontmatter":{"status":"public","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of an if statement executes repeatedly, as long as the condition holds","shortCorrection":"The body of an if statement executes at most once","text":[{"id":"ofj6","sections":["2"]},{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/IfRequiresElse/","name":"IfRequiresElse","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"Every if statement requires an else","shortCorrection":"If statements do not necessarily require an else","text":[{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/ImmutableRequiresFinalParameters/","name":"ImmutableRequiresFinalParameters","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Mutability","Class","Constructor","Method","Parameter"],"shortDescription":"Immutable classes need final constructor/method parameters","shortCorrection":"Immutable classes can have constructor/method parameters that are not final","text":null}},{"fields":{"slug":"/misconceptions/Java/ImplicitInterfaceImplementation/","name":"ImplicitInterfaceImplementation","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Inheritance"],"shortDescription":"Java implicitly produces implementations of any methods a class inherits from the interfaces it implements","shortCorrection":"Java does not implicitly produce implementations of any methods a class inherits from the interfaces it implements","text":null}},{"fields":{"slug":"/misconceptions/Java/IntegerDivisionToRational/","name":"IntegerDivisionToRational","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Number","Type"],"shortDescription":"Dividing two integers can produce a rational number","shortCorrection":"Dividing two integers always produces an integer","text":null}},{"fields":{"slug":"/misconceptions/Java/InterfaceExtendClass/","name":"InterfaceExtendClass","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Subtyping","Inheritance"],"shortDescription":"An interface can extend a class","shortCorrection":"An interface cannot extend a class","text":null}},{"fields":{"slug":"/misconceptions/Java/LargeIntegerLong/","name":"LargeIntegerLong","pl":"Java"},"frontmatter":{"status":"public","concepts":["Literal","Number","Type","Expression"],"shortDescription":"Large integer numbers have type long","shortCorrection":"Integer numbers without L or l suffix that are too large for an int are illegal","text":[{"id":"ofj6","sections":["10"]},{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/LiteralNoExpression/","name":"LiteralNoExpression","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Literal","Expression"],"shortDescription":"A literal is not an expression","shortCorrection":"Even an individual literal is an expression","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/LiteralString/","name":"LiteralString","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Literal","String","Argument"],"shortDescription":"When passing a literal string as argument to a method, no quotes are needed","shortCorrection":"String literals always must be surrounded by quotes","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/LocalVariablesAutoInitialized/","name":"LocalVariablesAutoInitialized","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Value","Assignment"],"shortDescription":"Local variables are automatically initialized","shortCorrection":"Local variables must be initialized explicitly","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/LoopBodyScopeImpliesLoopLifetime/","name":"LoopBodyScopeImpliesLoopLifetime","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Lifetime","Scope"],"shortDescription":"Lifetime of variables declared in a loop body extends across all loop iterations","shortCorrection":"Lifetime of variables declared in a loop body is limited to one loop iteration","text":null}},{"fields":{"slug":"/misconceptions/Java/LoopTerminatingCondition/","name":"LoopTerminatingCondition","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Loop","Conditional","ControlFlow"],"shortDescription":"For and while loops end when the condition becomes true","shortCorrection":"For and while loops end when the condition becomes false","text":null}},{"fields":{"slug":"/misconceptions/Java/MapToBooleanWithConditionalOperator/","name":"MapToBooleanWithConditionalOperator","pl":"Java"},"frontmatter":{"status":"public","concepts":["Conditional","Expression","Operator","Boolean"],"shortDescription":"To map a boolean expression to a boolean, a conditional operator is necessary","shortCorrection":"To map a boolean expression to a boolean, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Java/MapToBooleanWithIf/","name":"MapToBooleanWithIf","pl":"Java"},"frontmatter":{"status":"public","concepts":["Conditional","Statement","Boolean"],"shortDescription":"To map a boolean expression to a boolean, an if statement is necessary","shortCorrection":"To map a boolean expression to a boolean, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Java/MethodAsField/","name":"MethodAsField","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Field","Object","Class"],"shortDescription":"Each object contains its own special fields for all of its methods","shortCorrection":"Each object contains a special field referring to its class, and the class knows about its methods","text":null}},{"fields":{"slug":"/misconceptions/Java/MethodWithoutReturnType/","name":"MethodWithoutReturnType","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Type"],"shortDescription":"A method declaration does not need to include a return type","shortCorrection":"A method declaration must include a return type","text":null}},{"fields":{"slug":"/misconceptions/Java/MethodsWithoutClass/","name":"MethodsWithoutClass","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Class"],"shortDescription":"Methods can be defined outside a class","shortCorrection":"Methods must be defined inside a class","text":null}},{"fields":{"slug":"/misconceptions/Java/MultiReferenceVariable/","name":"MultiReferenceVariable","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Reference","Variable","Object"],"shortDescription":"A reference variable can point to multiple objects","shortCorrection":"A reference variable can point to only one object at a time","text":null}},{"fields":{"slug":"/misconceptions/Java/MultiValueVariable/","name":"MultiValueVariable","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Variable","Value"],"shortDescription":"A variable can contain more than one value","shortCorrection":"A variable can contain only one value at a time","text":[{"id":"ssj4","sections":["1"]}]}},{"fields":{"slug":"/misconceptions/Java/MultidimensionalArray/","name":"MultidimensionalArray","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"A multi-dimensional array is one single array object","shortCorrection":"A multi-dimensional is a structure of nested arrays","text":null}},{"fields":{"slug":"/misconceptions/Java/MultipleSuperclasses/","name":"MultipleSuperclasses","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Subtyping"],"shortDescription":"A class can have multiple superclasses","shortCorrection":"A class can have only one direct superclass","text":null}},{"fields":{"slug":"/misconceptions/Java/MustInitializeFieldInConstructor/","name":"MustInitializeFieldInConstructor","pl":"Java"},"frontmatter":{"status":"public","concepts":["Assignment","Constructor","Field","Value","Variable"],"shortDescription":"Constructors must assign values to all fields","shortCorrection":"Constructors do not need to assign values to all fields","text":null}},{"fields":{"slug":"/misconceptions/Java/NamedTypeParameter/","name":"NamedTypeParameter","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type","Parameter","Name"],"shortDescription":"To instantiate a generic type, for each type parameter one has to specify both the name and the type","shortCorrection":"To instantiate a generic type, for each type parameter one only needs to specify the type","text":null}},{"fields":{"slug":"/misconceptions/Java/NestedObjectsImplyNestedClasses/","name":"NestedObjectsImplyNestedClasses","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Object"],"shortDescription":"If objects are part of a containment hierarchy, their classes are nested, too","shortCorrection":"Classes are independent of object containment","text":null}},{"fields":{"slug":"/misconceptions/Java/NestedPackages/","name":"NestedPackages","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Member"],"shortDescription":"Packages can contain other packages which have access to members of the containing package","shortCorrection":"Sub-packages are independent of their parent packages and do not have special access rights","text":null}},{"fields":{"slug":"/misconceptions/Java/NoAtomicExpression/","name":"NoAtomicExpression","pl":"Java"},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/NoCallOnStringLiteral/","name":"NoCallOnStringLiteral","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","String","Literal"],"shortDescription":"One cannot invoke methods on String literals","shortCorrection":"One can invoke methods on String literals","text":null}},{"fields":{"slug":"/misconceptions/Java/NoCastIfSameSize/","name":"NoCastIfSameSize","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Variable","Value","Number","Type"],"shortDescription":"If a variable is at least as big (bit-width) as a value, then no cast is needed to a assign the value to the variable","shortCorrection":"A variable being at least as big (bit-width) as a value may not be sufficient to avoid a cast when assigning the value to the variable","text":null}},{"fields":{"slug":"/misconceptions/Java/NoCharEscape/","name":"NoCharEscape","pl":"Java"},"frontmatter":{"status":"draft","concepts":["String","Literal"],"shortDescription":"\\ is a normal character in char and String literals","shortCorrection":"\\ is an escape character in char and String literals","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/NoEmptyConstructor/","name":"NoEmptyConstructor","pl":"Java"},"frontmatter":{"status":"public","concepts":["Constructor"],"shortDescription":"A constructor must do something","shortCorrection":"A constructor's body can be empty","text":null}},{"fields":{"slug":"/misconceptions/Java/NoFieldInheritance/","name":"NoFieldInheritance","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Object","Class","Field"],"shortDescription":"An object contains only the fields declared in its class","shortCorrection":"An object contains the fields declared in its class and all its superclasses","text":null}},{"fields":{"slug":"/misconceptions/Java/NoFieldlessObjects/","name":"NoFieldlessObjects","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Object","Field"],"shortDescription":"Objects without instance variables can't exist","shortCorrection":"Objects can have any number of instance variables, including zero","text":null}},{"fields":{"slug":"/misconceptions/Java/NoFloatLiterals/","name":"NoFloatLiterals","pl":"Java"},"frontmatter":{"status":"public","concepts":["Literal","Number","Type"],"shortDescription":"There are no float literals","shortCorrection":"An F or f suffix can turn a number into a float literal","text":null}},{"fields":{"slug":"/misconceptions/Java/NoImplicitWidening/","name":"NoImplicitWidening","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type"],"shortDescription":"Smaller types are never automatically converted into bigger ones without an explicit cast","shortCorrection":"Smaller types can be automatically converted into bigger ones even without an explicit cast","text":null}},{"fields":{"slug":"/misconceptions/Java/NoInsideMethodCallInConstructor/","name":"NoInsideMethodCallInConstructor","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Constructor","Object"],"shortDescription":"It is foirbidden to call other methods on the same object while inside its constructor","shortCorrection":"It is allow to call other methods on the same object while inside its constructor","text":null}},{"fields":{"slug":"/misconceptions/Java/NoJaggedArrays/","name":"NoJaggedArrays","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Multi-dimensional arrays have a rectangular shape","shortCorrection":"Multi-dimensional arrays can have a jagged shape","text":null}},{"fields":{"slug":"/misconceptions/Java/NoLocalVariables/","name":"NoLocalVariables","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Variable","Stack"],"shortDescription":"There are no local variables","shortCorrection":"Methods can have local variables","text":null}},{"fields":{"slug":"/misconceptions/Java/NoLongLiterals/","name":"NoLongLiterals","pl":"Java"},"frontmatter":{"status":"public","concepts":["Literal","Number","Type"],"shortDescription":"There are no long literals","shortCorrection":"An L or l suffix can turn a number into a long literal","text":[{"id":"ofj6","sections":["10"]},{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/NoMethodInheritance/","name":"NoMethodInheritance","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Inheritance","Field","Method","Class"],"shortDescription":"Subclasses inherit fields but not methods","shortCorrection":"Subclasses inherit both fields and methods","text":null}},{"fields":{"slug":"/misconceptions/Java/NoReservedWords/","name":"NoReservedWords","pl":"Java"},"frontmatter":{"status":"public","concepts":["Name"],"shortDescription":"Every sequence of letters and digits starting with a letter can be used as an identifier","shortCorrection":"Some character sequences are reserved for use as keywords and cannot be used as identifiers","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/NoShortCircuit/","name":"NoShortCircuit","pl":"Java"},"frontmatter":{"status":"public","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"shortDescription":"&& and || always evaluate both operands","shortCorrection":"&& and || evaluate their right operand only if absolutely necessary","text":null}},{"fields":{"slug":"/misconceptions/Java/NoSingleLogicAnd/","name":"NoSingleLogicAnd","pl":"Java"},"frontmatter":{"status":"public","concepts":["Operator","Boolean"],"shortDescription":"& is only a bitwise AND","shortCorrection":"& for boolean operands is a logical AND","text":null}},{"fields":{"slug":"/misconceptions/Java/NoStringToString/","name":"NoStringToString","pl":"Java"},"frontmatter":{"status":"draft","concepts":["String","Method","Call"],"shortDescription":"One cannot invoke toString() on a String","shortCorrection":"One can invoke toString() on a String","text":null}},{"fields":{"slug":"/misconceptions/Java/NullIsObject/","name":"NullIsObject","pl":"Java"},"frontmatter":{"status":"public","concepts":["Reference","Object","Null","Literal","Value"],"shortDescription":"null is an object","shortCorrection":"null is a reference pointing to no object","text":[{"id":"ofj6","sections":["4"]}]}},{"fields":{"slug":"/misconceptions/Java/NullPointerExceptionCompileTime/","name":"NullPointerExceptionCompileTime","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception"],"shortDescription":"NullPointerExceptions are detected at compile time","shortCorrection":"NullPointerExceptions are detected at runtime","text":null}},{"fields":{"slug":"/misconceptions/Java/NumericToBooleanCoercion/","name":"NumericToBooleanCoercion","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Number","Type","Boolean"],"shortDescription":"Numeric types can be coerced to boolean","shortCorrection":"Numeric types cannot be coerced to boolean","text":null}},{"fields":{"slug":"/misconceptions/Java/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed","pl":"Java"},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Expression","Name"],"shortDescription":"A variable is needed to instantiate an object","shortCorrection":"Objects have no name and can exist without a variable referring to them","text":[{"id":"ofj6","sections":["3","4"]}]}},{"fields":{"slug":"/misconceptions/Java/OnlyInnermostArrayElements/","name":"OnlyInnermostArrayElements","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Only the elements of the innermost array of a multi-dimensional array are accessible","shortCorrection":"Also the elements of outer arrays of a multi-dimensional array are accessible","text":null}},{"fields":{"slug":"/misconceptions/Java/OutOfBoundsElementsAreNull/","name":"OutOfBoundsElementsAreNull","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Array","Null"],"shortDescription":"Out-of-bounds array elements are null","shortCorrection":"Out-of-bounds array elements cannot be accessed","text":null}},{"fields":{"slug":"/misconceptions/Java/OutsideInMethodNesting/","name":"OutsideInMethodNesting","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Call","Expression","Function","Composition"],"shortDescription":"Nested method calls are invoked outside in","shortCorrection":"Nested method calls are invoked inside out","text":[{"id":"ofj6","sections":["1","2","3"]}]}},{"fields":{"slug":"/misconceptions/Java/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Call","Expression"],"shortDescription":"() are optional for method calls without arguments","shortCorrection":"() are mandatory even for method calls without arguments","text":null}},{"fields":{"slug":"/misconceptions/Java/PreIncrementBeforeLoop/","name":"PreIncrementBeforeLoop","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Operator","Loop","ControlFlow"],"shortDescription":"Pre-increment in update part of for loop means increment before loop body","shortCorrection":"Pre-increment in update part of for loop means same as pre-increment anywhere else","text":null}},{"fields":{"slug":"/misconceptions/Java/PrimitiveIsObject/","name":"PrimitiveIsObject","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Primitive","Value","Object"],"shortDescription":"Primitive values are heap objects","shortCorrection":"Primitive values are not objects","text":null}},{"fields":{"slug":"/misconceptions/Java/PrimitiveTypeParameter/","name":"PrimitiveTypeParameter","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type","Parameter","Primitive"],"shortDescription":"Type parameters of generic types can be instantiated with primitive types","shortCorrection":"Type parameters of generic types need to be instantiated with reference types","text":null}},{"fields":{"slug":"/misconceptions/Java/PrimitiveVariablesDynamicallyTyped/","name":"PrimitiveVariablesDynamicallyTyped","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type","Value"],"shortDescription":"The type of a primitive variable depends on its value","shortCorrection":"The type of a primitive variable is fixed and does not depend on its value","text":null}},{"fields":{"slug":"/misconceptions/Java/PrivateAccessibleInSubclass/","name":"PrivateAccessibleInSubclass","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Member","Field","Method","Inheritance"],"shortDescription":"Private members of a superclass are accessible from a subclass","shortCorrection":"Private members of a superclass are not accessible from a subclass","text":null}},{"fields":{"slug":"/misconceptions/Java/PrivateFieldsImplyImmutability/","name":"PrivateFieldsImplyImmutability","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Mutability","Class","Field","AccessModifier"],"shortDescription":"A class where all fields are private is immutable","shortCorrection":"A class where all fields are private can still be mutable","text":null}},{"fields":{"slug":"/misconceptions/Java/PrivateFromOtherInstance/","name":"PrivateFromOtherInstance","pl":"Java"},"frontmatter":{"status":"public","concepts":["AccessModifier","Member"],"shortDescription":"An object cannot access private members of other objects of the same class","shortCorrection":"An object can access private members of all other objects of the same class","text":[{"id":"ofj6","sections":["6"]}]}},{"fields":{"slug":"/misconceptions/Java/PrivateFromStatic/","name":"PrivateFromStatic","pl":"Java"},"frontmatter":{"status":"public","concepts":["AccessModifier","Member","Static"],"shortDescription":"Static methods cannot access private members of instances of same class","shortCorrection":"Static methods can access private members of instances of same class","text":[{"id":"ofj6","sections":["6"]}]}},{"fields":{"slug":"/misconceptions/Java/PrivateMeansFinal/","name":"PrivateMeansFinal","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Mutability","Field","AccessModifier"],"shortDescription":"A private field cannot be changed","shortCorrection":"Even a private field can be mutable","text":null}},{"fields":{"slug":"/misconceptions/Java/RationalLiterals/","name":"RationalLiterals","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Number","Literal"],"shortDescription":"Rational fractions are literals","shortCorrection":"Rational fractions are divisions of two integer literals","text":null}},{"fields":{"slug":"/misconceptions/Java/RecursiveActivationsShareFrame/","name":"RecursiveActivationsShareFrame","pl":"Java"},"frontmatter":{"status":"public","concepts":["Recursion","Stack"],"shortDescription":"Recursive calls of a method share a stack frame","shortCorrection":"Each recursive call of a method gets its own stack frame","text":null}},{"fields":{"slug":"/misconceptions/Java/RecursiveCallSiteNoReturn/","name":"RecursiveCallSiteNoReturn","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Recursion","Call"],"shortDescription":"Tail-recursive call sites of non-void methods need no return statement","shortCorrection":"In non-void methods, even tail-recursive call sites need a return statement","text":null}},{"fields":{"slug":"/misconceptions/Java/RecursiveMethodImpliesRecursiveType/","name":"RecursiveMethodImpliesRecursiveType","pl":"Java"},"frontmatter":{"status":"public","concepts":["Recursion","Method","Type"],"shortDescription":"A class with a recursive method represents part of a recursive data structure","shortCorrection":"A class having a recursive method does not imply that it is part of a recursive data structure","text":null}},{"fields":{"slug":"/misconceptions/Java/RecursiveMethodNeedsIfElse/","name":"RecursiveMethodNeedsIfElse","pl":"Java"},"frontmatter":{"status":"public","concepts":["Recursion","Method","Conditional","ControlFlow"],"shortDescription":"A recursive method needs to contain an if-else statement","shortCorrection":"A recursive method does not necessarily need to contain an if-else statement","text":null}},{"fields":{"slug":"/misconceptions/Java/ReferenceIntoStack/","name":"ReferenceIntoStack","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Reference","Stack"],"shortDescription":"References can point into the stack","shortCorrection":"References can only point into the heap","text":null}},{"fields":{"slug":"/misconceptions/Java/ReferenceToBooleanCoercion/","name":"ReferenceToBooleanCoercion","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Reference","Type","Boolean"],"shortDescription":"Every reference type can be coerced to boolean","shortCorrection":"Not every reference type can be coerced to boolean","text":null}},{"fields":{"slug":"/misconceptions/Java/ReferenceToIntegerConversion/","name":"ReferenceToIntegerConversion","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Reference","Type","Number"],"shortDescription":"One can cast between references and ints","shortCorrection":"One cannot cast between references and ints","text":null}},{"fields":{"slug":"/misconceptions/Java/ReferenceToVariable/","name":"ReferenceToVariable","pl":"Java"},"frontmatter":{"status":"public","concepts":["Reference","Variable"],"shortDescription":"References can point to variables","shortCorrection":"References can only point to heap objects","text":[{"id":"ofj6","sections":["3"]}]}},{"fields":{"slug":"/misconceptions/Java/ReferringToRecursiveStructureMakesRecursive/","name":"ReferringToRecursiveStructureMakesRecursive","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Recursion"],"shortDescription":"A class referring to a recursive data structure is (indirectly) part of that recursion as well","shortCorrection":"If a class refers to a recursive data structure, it is not necessarily part of that recursion","text":null}},{"fields":{"slug":"/misconceptions/Java/ReturnCall/","name":"ReturnCall","pl":"Java"},"frontmatter":{"status":"public","concepts":["Return","Method","Call"],"shortDescription":"Return statements need () around the return value","shortCorrection":"Return statements do not need () around the return value","text":[{"id":"ofj6","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ReturnUnwindsMultipleFrames/","name":"ReturnUnwindsMultipleFrames","pl":"Java"},"frontmatter":{"status":"public","concepts":["Call","Return","Stack","Recursion"],"shortDescription":"A return statement can unwind multiple call stack frames","shortCorrection":"A return statement pops exactly one call stack frame","text":null}},{"fields":{"slug":"/misconceptions/Java/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Java"},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator","Associativity"],"shortDescription":"Chained accesses are invoked from right to left","shortCorrection":"Chained accesses are invoked from left to right","text":null}},{"fields":{"slug":"/misconceptions/Java/RuntimeExceptionChecked/","name":"RuntimeExceptionChecked","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","Subtyping"],"shortDescription":"RuntimeExceptions are checked exceptions","shortCorrection":"RuntimeExceptions are unchecked exceptions","text":null}},{"fields":{"slug":"/misconceptions/Java/SingleQuoteString/","name":"SingleQuoteString","pl":"Java"},"frontmatter":{"status":"draft","concepts":["String","Literal"],"shortDescription":"String literals can be in single quotes","shortCorrection":"String literals must be in double quotes","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/StackTraceIsCallHistory/","name":"StackTraceIsCallHistory","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Stack","Method","Call"],"shortDescription":"A stack trace is the sequence of previously called methods","shortCorrection":"A stack trace only includes the currently active methods","text":null}},{"fields":{"slug":"/misconceptions/Java/StaticCallPolymorphic/","name":"StaticCallPolymorphic","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Call","Polymorphism","Parameter","Type"],"shortDescription":"A static method call is dispatched polymorphically at runtime based on the argument types","shortCorrection":"A static method call is dispatched based on the declared types of the arguments","text":null}},{"fields":{"slug":"/misconceptions/Java/StaticDispatch/","name":"StaticDispatch","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Inheritance","Method","Call","Subtyping"],"shortDescription":"The method to be called is determined by the static type","shortCorrection":"The method to be called is determined by the dynamic type","text":null}},{"fields":{"slug":"/misconceptions/Java/StringLengthField/","name":"StringLengthField","pl":"Java"},"frontmatter":{"status":"draft","concepts":["String","Field","Method"],"shortDescription":"One can know the length of a String object by accessing its length field","shortCorrection":"One can know the length of a String object by calling its length method","text":null}},{"fields":{"slug":"/misconceptions/Java/StringLiteralNoObject/","name":"StringLiteralNoObject","pl":"Java"},"frontmatter":{"status":"public","concepts":["Literal","String"],"shortDescription":"One needs to call the String constructor to get a String object from a literal","shortCorrection":"A String literal represents a String object and can be treated as such","text":[{"id":"ofj6","sections":["1","2"]},{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/StringPlusStringifiesExpression/","name":"StringPlusStringifiesExpression","pl":"Java"},"frontmatter":{"status":"public","concepts":["String","Expression","Operator"],"shortDescription":"String concatenation stringifies non-String operand expressions","shortCorrection":"String concatenation evaluates non-String operand expressions and casts value to String","text":null}},{"fields":{"slug":"/misconceptions/Java/StringRepetitionOperator/","name":"StringRepetitionOperator","pl":"Java"},"frontmatter":{"status":"draft","concepts":["String","Number","Repetition"],"shortDescription":"The multiplication operator can repeat a String a number of times","shortCorrection":"The multiplication operator does not accept a String and a number","text":null}},{"fields":{"slug":"/misconceptions/Java/SubtypeCompatibleWithSupertype/","name":"SubtypeCompatibleWithSupertype","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Subtyping","Type","Inheritance","Reference"],"shortDescription":"A variable of a subtype can reference an object of a supertype","shortCorrection":"A variable of a subtype cannot reference an object of a supertype","text":null}},{"fields":{"slug":"/misconceptions/Java/SuperAlwaysHasParentheses/","name":"SuperAlwaysHasParentheses","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Call","Inheritance"],"shortDescription":"To call a method on a superclass, parentheses are needed after the keyword super","shortCorrection":"To call a method on a superclass, it is wrong to write parentheses after the keyword super","text":null}},{"fields":{"slug":"/misconceptions/Java/SuperNotFirstStatement/","name":"SuperNotFirstStatement","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Inheritance","Call"],"shortDescription":"super() can be called anywhere in the constructor of a subclass","shortCorrection":"super() must be called in the first statement in the constructor of a subclass","text":null}},{"fields":{"slug":"/misconceptions/Java/SuperclassObjectAllocated/","name":"SuperclassObjectAllocated","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Allocation","Class","Object","Inheritance"],"shortDescription":"When instantiating an object of a subclass, an object of a superclass is also allocated","shortCorrection":"When instantiating an object of a subclass, just that object is allocated","text":null}},{"fields":{"slug":"/misconceptions/Java/SupertypeIncompatibleWithSubtype/","name":"SupertypeIncompatibleWithSubtype","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Inheritance","Subtyping","Type","Reference"],"shortDescription":"A variable of a supertype cannot reference an object of a subtype","shortCorrection":"A variable of a supertype can reference an object of a subtype","text":null}},{"fields":{"slug":"/misconceptions/Java/TargetTyping/","name":"TargetTyping","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Type","Number","Expression"],"shortDescription":"The type of a numerical expression depends on the type expected by the surrounding context","shortCorrection":"The type of a numerical expression is determined by the expression","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/ThisAsField/","name":"ThisAsField","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Field","Variable","Reference","Object","Self"],"shortDescription":"this is a special field in the object","shortCorrection":"this is a special local variable in the stack frame","text":null}},{"fields":{"slug":"/misconceptions/Java/ThisAssignable/","name":"ThisAssignable","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"One can assign to this","shortCorrection":"One cannot assign to this","text":[{"id":"ofj6","sections":["3"]}]}},{"fields":{"slug":"/misconceptions/Java/ThisCanBeNull/","name":"ThisCanBeNull","pl":"Java"},"frontmatter":{"status":"public","concepts":["Null","Reference","Self"],"shortDescription":"this can be null","shortCorrection":"this is never null","text":null}},{"fields":{"slug":"/misconceptions/Java/ThisExistsInStaticMethod/","name":"ThisExistsInStaticMethod","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Reference","Object","Static","Method","Self"],"shortDescription":"this is a local variable, also in static methods","shortCorrection":"this does not exist in static methods","text":[{"id":"ofj6","sections":["6","13"]}]}},{"fields":{"slug":"/misconceptions/Java/ThisInConstructorIsNull/","name":"ThisInConstructorIsNull","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Constructor","Null","Reference","Self"],"shortDescription":"In a constructor, this is null","shortCorrection":"In a constructor, this is never null","text":null}},{"fields":{"slug":"/misconceptions/Java/ThisNoExpression/","name":"ThisNoExpression","pl":"Java"},"frontmatter":{"status":"public","concepts":["Expression","Self"],"shortDescription":"The name this is not an expression","shortCorrection":"Even the name this on its own is an expression","text":null}},{"fields":{"slug":"/misconceptions/Java/ToStringPrints/","name":"ToStringPrints","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","String","Output","Evaluation"],"shortDescription":"Invoking toString() prints something","shortCorrection":"Invoking toString() does not produce any output","text":null}},{"fields":{"slug":"/misconceptions/Java/TryCatchMandatory/","name":"TryCatchMandatory","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"When a piece of code can throw an exception, it must be surrounded with a try/catch block","shortCorrection":"When a piece of code can throw an exception, it is optional to surround it with a try/catch block","text":null}},{"fields":{"slug":"/misconceptions/Java/TryFinishes/","name":"TryFinishes","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Exceptions get thrown at the end of the try block","shortCorrection":"Exceptions get thrown immediately when they occur","text":null}},{"fields":{"slug":"/misconceptions/Java/UndeclaredVariables/","name":"UndeclaredVariables","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Variable"],"shortDescription":"Variables can be used even without being declared beforehand","shortCorrection":"Variables must be declared before they are used","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/UnqualifiedNamesMustDiffer/","name":"UnqualifiedNamesMustDiffer","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Name","Class","Scope"],"shortDescription":"The unqualified names of different classes must be different","shortCorrection":"Classes in different packages can have the same unqualified name","text":null}},{"fields":{"slug":"/misconceptions/Java/UntypedVariables/","name":"UntypedVariables","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Variable","Type"],"shortDescription":"Variable declarations don't need a type","shortCorrection":"Variable declarations need a type","text":[{"id":"ssj4","sections":["1"]},{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/UseOfSelfTypeImpliesRecursiveType/","name":"UseOfSelfTypeImpliesRecursiveType","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Class","Method","Variable","Parameter","Return","Value","Type","Recursion"],"shortDescription":"If a class has a method that has a local variable, parameter, or return value with the class as its type, the class is a recursive type","shortCorrection":"A class can have methods with a local variable, parameter, or return value with the class as its type without being a recursive type","text":null}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldExpressions/","name":"VariablesHoldExpressions","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Expression","Assignment"],"shortDescription":"= stores an expression in a variable","shortCorrection":"= evaluates an expression and stores its value in a variable","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldObjects/","name":"VariablesHoldObjects","pl":"Java"},"frontmatter":{"status":"public","concepts":["Variable","Object","Reference"],"shortDescription":"A variable of a reference type contains a whole object","shortCorrection":"A variable of a reference type contains a reference to an object","text":null}},{"fields":{"slug":"/misconceptions/Java/VoidMethodNotRecursive/","name":"VoidMethodNotRecursive","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Type","Recursion"],"shortDescription":"A method with void return type can't be recursive","shortCorrection":"A method with void return type can be recursive","text":null}},{"fields":{"slug":"/misconceptions/Java/VoidMethodReturnsValue/","name":"VoidMethodReturnsValue","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Method","Type","Return","Value"],"shortDescription":"A method with void return type can return a value","shortCorrection":"A method with void return type cannot return a value","text":null}},{"fields":{"slug":"/misconceptions/Java/ZeroDigitsCompress/","name":"ZeroDigitsCompress","pl":"Java"},"frontmatter":{"status":"draft","concepts":["Number"],"shortDescription":"In integer numbers, decimal digits with value `0` take less storage than decimal digits with other values","shortCorrection":"In integer numbers, all decimal digits take the same amount of storage","text":[{"id":"ssj4","sections":["2"]}]}},{"fields":{"slug":"/misconceptions/JavaScript/AccessingInexistentPropertyError/","name":"AccessingInexistentPropertyError","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Exception","Field","Member","Object","Undefined"],"shortDescription":"Accessing a non existent property on an object produces an error","shortCorrection":"Accessing a non existent property on an object evaluates to undefined","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ArrowFunctionNoImpliedReturn/","name":"ArrowFunctionNoImpliedReturn","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Return","Expression","Function"],"shortDescription":"Even when an arrow function consists just of an expression, the return keyword must be explicitly written","shortCorrection":"When an arrow function consists just of an expression, the return keyword is implied","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ArrowFunctionRequiresFunctionKeyword/","name":"ArrowFunctionRequiresFunctionKeyword","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Expression"],"shortDescription":"Arrow functions also require the keyword 'function'","shortCorrection":"Arrow functions do not require the keyword 'function'","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Assignment","Variable","Object","Reference"],"shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference pointing to the object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/CallbackParametersInCaller/","name":"CallbackParametersInCaller","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Argument","Parameter","Function","Value","Call"],"shortDescription":"Parameters of a callback function may be written as parameters of the caller function","shortCorrection":"A function that expects a callback has that callback function as a parameter","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/CharType/","name":"CharType","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["String","Type"],"shortDescription":"A single character is of type char","shortCorrection":"A single character is of type string","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ClassDefinesType/","name":"ClassDefinesType","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Class","Type"],"shortDescription":"The type of an object is equivalent to the type defined by its class definition","shortCorrection":"A class definition does not define a type; all objects have type object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ConditionalOperatorNotExpression/","name":"ConditionalOperatorNotExpression","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Expression","Operator","Conditional","ControlFlow"],"shortDescription":"The conditional operator is not an expression","shortCorrection":"The conditional operator is not an expression","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ConstDeclarationCanBeLeftUninitialized/","name":"ConstDeclarationCanBeLeftUninitialized","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Assignment","Variable"],"shortDescription":"Declarations of constants do not need to be immediately initialized","shortCorrection":"Declarations of constants need to be immediately initialized","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ConstReferenceImpliesImmutability/","name":"ConstReferenceImpliesImmutability","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Mutability","Reference"],"shortDescription":"An object referred to by a const variable is an immutable object","shortCorrection":"An object referred to by a const variable can be a mutable object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/EqualityOperatorComparesObjectsValues/","name":"EqualityOperatorComparesObjectsValues","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Equality","Object","Operator","Reference","Value"],"shortDescription":"The equality operator compares two objects' values","shortCorrection":"The equality operator compares two objects' references","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Operator","Equality","Type","Value"],"shortDescription":"The equality operator '==' compares only the types of the operands","shortCorrection":"The equality operator '==' compares only the values of the operands","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionAsValueWithParentheses/","name":"FunctionAsValueWithParentheses","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Value","Call"],"shortDescription":"To use a function as a value, one needs to have parentheses after its name","shortCorrection":"To use a function as a value, one just needs to write its name","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionOverloading/","name":"FunctionOverloading","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Argument","Parameter"],"shortDescription":"It is possible to create multiple functions with the same name but with different signatures","shortCorrection":"It not is possible to create multiple functions with the same name but with different signatures","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionsCannotBeImmediatelyInvoked/","name":"FunctionsCannotBeImmediatelyInvoked","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Call","Scope"],"shortDescription":"Functions cannot be called in the expression in which they are defined","shortCorrection":"Functions can be immediately called in the expression in which they are defined","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionsMustBeNamed/","name":"FunctionsMustBeNamed","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Name","Scope"],"shortDescription":"Every function definition requires an associated name","shortCorrection":"One can define a function without associating a name to it","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/IdentifierAsStringInBracketNotation/","name":"IdentifierAsStringInBracketNotation","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Expression","String","Field","Object"],"shortDescription":"An identifier used to access a property with the bracket notation is treated as a string","shortCorrection":"An identifier used to access a property with the bracket notation is firstly evaluated","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/MandatoryAssignment/","name":"MandatoryAssignment","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Assignment","Expression","Statement"],"shortDescription":"An expression must be assigned to have a valid statement","shortCorrection":"An expression alone, without an assignment, is already a valid statement","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/MapInPlace/","name":"MapInPlace","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Array","Return"],"shortDescription":"Map modifies the elements of the array on which it operates in place","shortCorrection":"Map returns a new array populated with the results of the callback function","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NoAtomicExpression/","name":"NoAtomicExpression","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NoBracketNotationForObjects/","name":"NoBracketNotationForObjects","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Object","Field"],"shortDescription":"Square brackets cannot be used to access properties of an object","shortCorrection":"Square brackets can be used to access properties of an object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NoFunctionCallsChaining/","name":"NoFunctionCallsChaining","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Expression","Call","Function","Precedence"],"shortDescription":"It is not allowed to chain function calls","shortCorrection":"Multiple function calls can be chained together","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NoGlobalObject/","name":"NoGlobalObject","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Object","Scope"],"shortDescription":"There isn't a global object","shortCorrection":"There is always a global object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NoReturnValue/","name":"NoReturnValue","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Undefined","Return","Value"],"shortDescription":"Functions without return statements return no value at all","shortCorrection":"Functions without return statements return undefined","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NullAndUndefinedAreTheSame/","name":"NullAndUndefinedAreTheSame","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Type","Value","Equality","Null","Undefined"],"shortDescription":"The values null and undefined are the same","shortCorrection":"null and undefined are two distinct values","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NullIsObject/","name":"NullIsObject","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Null","Object","Reference","Value","Literal"],"shortDescription":"null is an object","shortCorrection":"null is a reference pointing to no object","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/NumberOfParametersMatchArguments/","name":"NumberOfParametersMatchArguments","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Function","Call","Argument","Parameter"],"shortDescription":"Functions must be called with the same number of arguments as defined in their signature","shortCorrection":"Functions can be called with a different number of arguments as defined in their signature","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ObjectAsParameterIsCopied/","name":"ObjectAsParameterIsCopied","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Argument","Parameter","Object","Reference"],"shortDescription":"Objects are passed by value","shortCorrection":"Objects are passed by reference","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/PrototypesAreClasses/","name":"PrototypesAreClasses","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Prototype","Class"],"shortDescription":"JavaScript is based on a class-based object model","shortCorrection":"JavaScript is based on a prototype-based object model","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/StringRepetitionOperator/","name":"StringRepetitionOperator","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["String","Number","Repetition"],"shortDescription":"One can repeat a String by multiplying it with a number","shortCorrection":"One cannot repeat a String by multiplying it with a number","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/ThisAssignable/","name":"ThisAssignable","pl":"JavaScript"},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"One can assign to this","shortCorrection":"One cannot assign to this","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/TypeofArrayIsArray/","name":"TypeofArrayIsArray","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The typeof operator applied on an array returns 'array'","shortCorrection":"The typeof operator applied on an array returns 'object'","text":null}},{"fields":{"slug":"/misconceptions/JavaScript/TypeofNullIsNull/","name":"TypeofNullIsNull","pl":"JavaScript"},"frontmatter":{"status":"draft","concepts":["Value","Type"],"shortDescription":"The value null is of type 'null'","shortCorrection":"The value null is of type 'object'","text":null}},{"fields":{"slug":"/misconceptions/Python/AssignCompares/","name":"AssignCompares","pl":"Python"},"frontmatter":{"status":"public","concepts":["Assignment","Equality","Expression","Operator"],"shortDescription":"= compares two values","shortCorrection":"= assigns a value to a variable","text":null}},{"fields":{"slug":"/misconceptions/Python/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"Python"},"frontmatter":{"status":"public","concepts":["Allocation","Assignment","Object","Reference","Value","Variable"],"shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference to the object","text":null}},{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeAccesses/","name":"CannotChainAttributeAccesses","pl":"Python"},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator"],"shortDescription":"Attribute accesses cannot be chained together","shortCorrection":"Attribute accesses can be chained together","text":null}},{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeToObjectInstantiation/","name":"CannotChainAttributeToObjectInstantiation","pl":"Python"},"frontmatter":{"status":"public","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"shortDescription":"Method calls, and attribute accesses in general, cannot be chained to a constructor invocation.","shortCorrection":"Method calls, and attribute accesses in general, can be chained to a constructor invocation.","text":null}},{"fields":{"slug":"/misconceptions/Python/ComparisonWithBoolLiteral/","name":"ComparisonWithBoolLiteral","pl":"Python"},"frontmatter":{"status":"public","concepts":["Boolean","Equality","Evaluation","Expression","Literal","Operator"],"shortDescription":"To test whether an expression is True or False, one must compare it to True or to False","shortCorrection":"To test whether an expression is True or False, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Python/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Python"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-else is equivalent to sequence of two ifs","shortCorrection":"If-else can behave differently from sequence of two ifs","text":null}},{"fields":{"slug":"/misconceptions/Python/DeferredReturn/","name":"DeferredReturn","pl":"Python"},"frontmatter":{"status":"public","concepts":["Return","ControlFlow","Function","Call"],"shortDescription":"A return statement in the middle of a function doesn't return immediately","shortCorrection":"A return statement immediately returns from the function","text":null}},{"fields":{"slug":"/misconceptions/Python/IfIsLoop/","name":"IfIsLoop","pl":"Python"},"frontmatter":{"status":"public","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of an if-statement executes repeatedly, as long as the condition holds","shortCorrection":"The body of an if-statement executes at most once","text":null}},{"fields":{"slug":"/misconceptions/Python/InitCreates/","name":"InitCreates","pl":"Python"},"frontmatter":{"status":"public","concepts":["Allocation","Call","Constructor"],"shortDescription":"__init__ must create a new object","shortCorrection":"__init__ does not create the object, it just initializes it","text":null}},{"fields":{"slug":"/misconceptions/Python/InitReturnsObject/","name":"InitReturnsObject","pl":"Python"},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Return"],"shortDescription":"__init__ needs to return an object","shortCorrection":"__init__ cannot return values other than None","text":null}},{"fields":{"slug":"/misconceptions/Python/MapToBooleanWithIf/","name":"MapToBooleanWithIf","pl":"Python"},"frontmatter":{"status":"public","concepts":["Conditional","Statement","Boolean","Evaluation"],"shortDescription":"To map a boolean expression to a bool, an if statement is necessary","shortCorrection":"To map a boolean expression to a bool, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Python/MapToBooleanWithTernaryOperator/","name":"MapToBooleanWithTernaryOperator","pl":"Python"},"frontmatter":{"status":"public","concepts":["Conditional","Expression","Operator","Boolean"],"shortDescription":"To map a boolean expression to a bool, a ternary conditional operator is necessary","shortCorrection":"To map a boolean expression to a bool, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Python/MultipleValuesReturn/","name":"MultipleValuesReturn","pl":"Python"},"frontmatter":{"status":"public","concepts":["Value","Return","Function"],"shortDescription":"Functions can return multiple values","shortCorrection":"Functions can only return one value","text":null}},{"fields":{"slug":"/misconceptions/Python/NoAtomicExpression/","name":"NoAtomicExpression","pl":"Python"},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","text":null}},{"fields":{"slug":"/misconceptions/Python/NoEmptyInit/","name":"NoEmptyInit","pl":"Python"},"frontmatter":{"status":"public","concepts":["Constructor"],"shortDescription":"__init__ must do something","shortCorrection":"The body of __init__ can be empty","text":null}},{"fields":{"slug":"/misconceptions/Python/NoReservedWords/","name":"NoReservedWords","pl":"Python"},"frontmatter":{"status":"public","concepts":["Name"],"shortDescription":"Every sequence of letters and digits starting with a letter or an underscore can be used as an identifier","shortCorrection":"Some character sequences are reserved for use as keywords and cannot be used as identifiers","text":null}},{"fields":{"slug":"/misconceptions/Python/NoSequenceRepetition/","name":"NoSequenceRepetition","pl":"Python"},"frontmatter":{"status":"draft","concepts":["String","Sequence","Number","Repetition"],"shortDescription":"There is no operator that repeats sequences","shortCorrection":"The * operator can be used to repeat sequences","text":null}},{"fields":{"slug":"/misconceptions/Python/NoShortCircuit/","name":"NoShortCircuit","pl":"Python"},"frontmatter":{"status":"public","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"shortDescription":"and/or always evaluate both operands","shortCorrection":"and/or evaluate their right operand only if absolutely necessary","text":null}},{"fields":{"slug":"/misconceptions/Python/NoSingleLogicAnd/","name":"NoSingleLogicAnd","pl":"Python"},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator"],"shortDescription":"& is only a bitwise AND","shortCorrection":"& for boolean operands is a logical AND","text":null}},{"fields":{"slug":"/misconceptions/Python/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed","pl":"Python"},"frontmatter":{"status":"public","concepts":["Allocation","Call","Expression","Constructor","Name","Object"],"shortDescription":"A variable is needed to instantiate an object","shortCorrection":"Objects have no name and can exist without a variable referring to them","text":null}},{"fields":{"slug":"/misconceptions/Python/OutsideInFunctionNesting/","name":"OutsideInFunctionNesting","pl":"Python"},"frontmatter":{"status":"public","concepts":["Call","Composition","ControlFlow","Expression","Function"],"shortDescription":"Nested function calls are invoked outside in","shortCorrection":"Nested function calls are invoked inside out","text":null}},{"fields":{"slug":"/misconceptions/Python/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument","pl":"Python"},"frontmatter":{"status":"public","concepts":["Function","Call","Expression"],"shortDescription":"() are optional for function calls without arguments","shortCorrection":"() are mandatory even for function calls without arguments","text":null}},{"fields":{"slug":"/misconceptions/Python/PlusConcatenatesNumbers/","name":"PlusConcatenatesNumbers","pl":"Python"},"frontmatter":{"status":"draft","concepts":["String","Sequence","Number","Expression","Operator"],"shortDescription":"The plus operator can concatenate strings and numbers","shortCorrection":"The plus operator cannot concatenate strings and numbers","text":null}},{"fields":{"slug":"/misconceptions/Python/RecursiveFunctionNeedsIfElse/","name":"RecursiveFunctionNeedsIfElse","pl":"Python"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow","Recursion"],"shortDescription":"A recursive function needs to contain an if-else statement","shortCorrection":"A recursive function does not necessarily need to contain an if-else statement","text":null}},{"fields":{"slug":"/misconceptions/Python/ReturnCall/","name":"ReturnCall","pl":"Python"},"frontmatter":{"status":"public","concepts":["Call","Evaluation","Function","Return"],"shortDescription":"Return statements need () around the return value","shortCorrection":"Return statements do not need () around the return value","text":null}},{"fields":{"slug":"/misconceptions/Python/ReturnUnwindsMultipleFrames/","name":"ReturnUnwindsMultipleFrames","pl":"Python"},"frontmatter":{"status":"public","concepts":["Call","Recursion","Return","Stack"],"shortDescription":"A return statement can unwind multiple call stack frames","shortCorrection":"A return statement pops exactly one call stack frame","text":null}},{"fields":{"slug":"/misconceptions/Python/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Python"},"frontmatter":{"status":"public","concepts":["Associativity","Call","ControlFlow","Evaluation","Expression","Field","Method"],"shortDescription":"Chained accesses are invoked from right to left","shortCorrection":"Chained accesses are invoked from left to right","text":null}},{"fields":{"slug":"/misconceptions/Python/SelfAssignable/","name":"SelfAssignable","pl":"Python"},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"Reassigning self changes the object on which a method is called","shortCorrection":"Reassigning self does not change the object on which a method is called","text":null}},{"fields":{"slug":"/misconceptions/Python/SelfNoExpression/","name":"SelfNoExpression","pl":"Python"},"frontmatter":{"status":"public","concepts":["Expression","Self"],"shortDescription":"The name self is not an expression","shortCorrection":"Even the name self on its own is an expression","text":null}},{"fields":{"slug":"/misconceptions/Python/StringLiteralNoObject/","name":"StringLiteralNoObject","pl":"Python"},"frontmatter":{"status":"public","concepts":["Expression","Literal","Name","String"],"shortDescription":"One needs to call str to instantiate a str object from a string literal","shortCorrection":"A string literal represents a str object and can be treated as such","text":null}},{"fields":{"slug":"/misconceptions/Python/VariablesHoldExpressions/","name":"VariablesHoldExpressions","pl":"Python"},"frontmatter":{"status":"public","concepts":["Variable","Expression","Assignment","Value"],"shortDescription":"= stores an expression: it stores a reference to the expression in a variable","shortCorrection":"= evaluates an expression and stores a reference to its value in a variable","text":null}},{"fields":{"slug":"/misconceptions/Python/VariablesHoldObjects/","name":"VariablesHoldObjects","pl":"Python"},"frontmatter":{"status":"public","concepts":["Variable","Object","Reference","Value"],"shortDescription":"A variable contains a whole object","shortCorrection":"A variable contains a reference to an object","text":null}},{"fields":{"slug":"/misconceptions/Scratch/BaseCaseNotNeeded/","name":"BaseCaseNotNeeded","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Recursion","Conditional","Call"],"shortDescription":"Recursive computations do not necessarily need a base case","shortCorrection":"Recursive computations need a base case to terminate","text":null}},{"fields":{"slug":"/misconceptions/Scratch/CompareBooleanToConstant/","name":"CompareBooleanToConstant","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator","Equality"],"shortDescription":"To test whether an expression evaluates to true or false, one must compare it to a constant","shortCorrection":"To test whether an expression evaluates to true or false, one can just use it","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-then-else block is equivalent to sequence of two if-then blocks","shortCorrection":"If-then-else block can behave differently from sequence of two if-then blocks","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ElseAlwaysExecutes/","name":"ElseAlwaysExecutes","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"The else branch of an if-then-else block always executes","shortCorrection":"The else branch of an if-then-else block only executes if the condition evaluates to false","text":null}},{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesListIdentities/","name":"EqualityOperatorComparesListIdentities","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Expression"],"shortDescription":"(list a) = (list b) compares the identities of list a and list b","shortCorrection":"(list a) = (list b) compares the contents of list a and list b","text":null}},{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Operator","Equality","Type","Value"],"shortDescription":"() = () compares only the types of its operands","shortCorrection":"() = () compares the values of its operands","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ExpressionAssigns/","name":"ExpressionAssigns","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Expression","Assignment","Variable"],"shortDescription":"An expression that reads a variable also updates its value after the evaluation","shortCorrection":"A variable is only written using an assignment","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ListLengthCannotBeZero/","name":"ListLengthCannotBeZero","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Array"],"shortDescription":"A list cannot have a length of 0 items","shortCorrection":"A list can have a length of 0 items","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ListsHomogeneous/","name":"ListsHomogeneous","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Array","Type"],"shortDescription":"All items in a list must have the same type","shortCorrection":"A list can contain items of different types","text":null}},{"fields":{"slug":"/misconceptions/Scratch/MissingElseTerminates/","name":"MissingElseTerminates","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"Blocks following an if without else will not execute if the condition is false","shortCorrection":"Blocks following an if without else will execute even if the condition is false","text":null}},{"fields":{"slug":"/misconceptions/Scratch/RepeatDistributes/","name":"RepeatDistributes","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Loop","ControlFlow"],"shortDescription":"Each block in a loop is repeated individually","shortCorrection":"The whole sequence of blocks in a loop is repeated","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ResetStateEachLoopIteration/","name":"ResetStateEachLoopIteration","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Loop","ControlFlow"],"shortDescription":"The computation of all loop iterations starts from the state before the loop","shortCorrection":"The computation of a loop iteration starts from the state that is based on everything that happened before, including prior iterations of the loop","text":null}},{"fields":{"slug":"/misconceptions/Scratch/ResetStateEachProgramExecution/","name":"ResetStateEachProgramExecution","pl":"Scratch"},"frontmatter":{"status":"public","concepts":["Variable","Lifetime"],"shortDescription":"Running a Scratch program first resets the state of the world and then executes the program","shortCorrection":"Running a Scratch program executes the program starting with the world in its current state","text":null}}]},"textbooks":{"nodes":[{"frontmatter":{"title":"Category Theory for Programmers","subtitle":null,"edition":null,"pl":null,"home":"https://github.com/hmemcpy/milewski-ctfp-pdf","baseUrl":null,"sections":null},"parent":{"name":"ctp"}},{"frontmatter":{"title":"Compilers: Principles, Techniques, and Tools","subtitle":null,"edition":"2nd Edition","pl":null,"home":"https://suif.stanford.edu/dragonbook/","baseUrl":null,"sections":null},"parent":{"name":"dragon"}},{"frontmatter":{"title":"nLab","subtitle":null,"edition":null,"pl":null,"home":"https://ncatlab.org/nlab/show/HomePage","baseUrl":null,"sections":null},"parent":{"name":"nlab"}},{"frontmatter":{"title":"Objects-First with Java","subtitle":"A Practical Introduction using BlueJ","edition":"6th Edition","pl":"Java","home":"https://www.bluej.org/objects-first/","baseUrl":null,"sections":[{"section":"1","title":"Objects and classes","url":null},{"section":"2","title":"Understanding class definitions","url":null},{"section":"3","title":"Object interaction","url":null},{"section":"4","title":"Grouping objects","url":null},{"section":"5","title":"Functional Processing of Collections (Advanced)","url":null},{"section":"6","title":"More-sophisticated behavior","url":null},{"section":"7","title":"Fixed-size collections  arrays","url":null},{"section":"8","title":"Designing classes","url":null},{"section":"9","title":"Well-behaved objects","url":null},{"section":"10","title":"Improving structure with inheritance","url":null},{"section":"11","title":"More about inheritance","url":null},{"section":"12","title":"Further abstraction techniques","url":null},{"section":"13","title":"Building graphical user interfaces","url":null},{"section":"14","title":"Handling errors","url":null},{"section":"15","title":"Designing applications","url":null},{"section":"16","title":"A case study","url":null},{"section":"Appendix A","title":"Working with a BlueJ project","url":null},{"section":"Appendix B","title":"Java data types","url":null},{"section":"Appendix C","title":"Operators","url":null},{"section":"Appendix D","title":"Java control structures","url":null},{"section":"Appendix E","title":"Running Java without BlueJ","url":null},{"section":"Appendix F","title":"Using the debugger","url":null},{"section":"Appendix G","title":"Unit unit-testing tools","url":null},{"section":"Appendix H","title":"Teamwork tools","url":null},{"section":"Appendix I","title":"Javadoc","url":null},{"section":"Appendix J","title":"Program style guide","url":null},{"section":"Appendix K","title":"Important library classes","url":null}]},"parent":{"name":"ofj6"}},{"frontmatter":{"title":"Sprechen Sie Java","subtitle":"Eine Einfhrung in das systematische Programmieren","edition":"4. Auflage","pl":"Java","home":"https://ssw.jku.at/Misc/JavaBuch/","baseUrl":null,"sections":[{"section":"1","title":"Grundlagen","url":null},{"section":"2","title":"Einfache Programme","url":null},{"section":"3","title":"Verzweigungen","url":null},{"section":"4","title":"Schleifen","url":null},{"section":"5","title":"Gleitkommazahlen","url":null},{"section":"6","title":"Methoden","url":null},{"section":"7","title":"Arrays","url":null},{"section":"8","title":"Zeichen","url":null},{"section":"9","title":"Strings","url":null},{"section":"10","title":"Klassen","url":null},{"section":"11","title":"Objektorientierung","url":null},{"section":"12","title":"Dynamische Datenstrukturen","url":null},{"section":"13","title":"Vererbung","url":null},{"section":"14","title":"Enumerationstypen","url":null},{"section":"15","title":"Generizitt","url":null},{"section":"16","title":"Rekursion","url":null},{"section":"17","title":"Schrittweise Verfeinerung","url":null},{"section":"18","title":"Pakete","url":null},{"section":"19","title":"Ausnahmebehandlung","url":null},{"section":"20","title":"Threads","url":null},{"section":"21","title":"Annotationen","url":null},{"section":"22","title":"Auszug aus der Java-Klassenbibliothek","url":null},{"section":"23","title":"Ausblick","url":null}]},"parent":{"name":"ssj4"}},{"frontmatter":{"title":"Types and Programming Languages","subtitle":null,"edition":null,"pl":null,"home":"https://www.cis.upenn.edu/~bcpierce/tapl/","baseUrl":null,"sections":null},"parent":{"name":"tapl"}}]}},"pageContext":{}},
    "staticQueryHashes": ["3649515864","4169798128"]}