{
    "componentChunkName": "component---src-pages-overview-symptoms-js",
    "path": "/overview/symptoms/",
    "result": {"data":{"misconceptions":{"nodes":[{"fields":{"slug":"/misconceptions/Java/AbstractClassMustImplementAbstractMethod/","name":"AbstractClassMustImplementAbstractMethod","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Inheritance","Implementation"],"shortDescription":"An abstract class must implement all abstract methods defined in its superclass"}},{"fields":{"slug":"/misconceptions/Java/AbstractClassNoImplementation/","name":"AbstractClassNoImplementation","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Inheritance"],"shortDescription":"An abstract class cannot contain implemented methods"}},{"fields":{"slug":"/misconceptions/Java/AddMemberAtRuntime/","name":"AddMemberAtRuntime","pl":"Java","symptoms":{"childMdx":{"excerpt":"A variant of this misconception (about being able to not add but  modify  methods)\nshowed up repeat…"}}},"frontmatter":{"status":"public","concepts":["Class","Method","Field","Allocation"],"shortDescription":"Set of class members can change at runtime"}},{"fields":{"slug":"/misconceptions/Java/AllClassesHaveDefaultConstructor/","name":"AllClassesHaveDefaultConstructor","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Constructor"],"shortDescription":"All classes automatically get a no-argument constructor"}},{"fields":{"slug":"/misconceptions/Java/AnyClassException/","name":"AnyClassException","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","Class"],"shortDescription":"Any class can be an exception class"}},{"fields":{"slug":"/misconceptions/Java/ArithmeticPlusPrecedes/","name":"ArithmeticPlusPrecedes","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["String","Expression","Operator","Precedence","Associativity"],"shortDescription":"Addition has higher precedence than string concatenation"}},{"fields":{"slug":"/misconceptions/Java/ArrayAccessWithParentheses/","name":"ArrayAccessWithParentheses","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Operator"],"shortDescription":"Parentheses are used to access an element in an array"}},{"fields":{"slug":"/misconceptions/Java/ArrayAllocationWithoutNew/","name":"ArrayAllocationWithoutNew","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Allocation"],"shortDescription":"Arrays are created without the new keyword"}},{"fields":{"slug":"/misconceptions/Java/ArrayBracketCountIsLength/","name":"ArrayBracketCountIsLength","pl":"Java","symptoms":{"childMdx":{"excerpt":"Here is an example of this misconception occurring in the initializer: And here is an example in th…"}}},"frontmatter":{"status":"draft","concepts":["Array","Allocation"],"shortDescription":"The number of brackets in an array type or an array initializer corresponds to the length of the array"}},{"fields":{"slug":"/misconceptions/Java/ArrayElementTypeRepeats/","name":"ArrayElementTypeRepeats","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The type of a multi-dimensional array is written as T[] T[] T[]"}},{"fields":{"slug":"/misconceptions/Java/ArrayElementsUntyped/","name":"ArrayElementsUntyped","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"Elements of arrays are untyped"}},{"fields":{"slug":"/misconceptions/Java/ArrayHasLengthMethod/","name":"ArrayHasLengthMethod","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Array","Method","Field"],"shortDescription":"To get the length of an array, one needs to call its length method"}},{"fields":{"slug":"/misconceptions/Java/ArrayInitializerContentsInBrackets/","name":"ArrayInitializerContentsInBrackets","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Literal"],"shortDescription":"Array initializers list the elements in square brackets"}},{"fields":{"slug":"/misconceptions/Java/ArrayLengthCannotBeZero/","name":"ArrayLengthCannotBeZero","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"An array cannot have a length of 0 elements"}},{"fields":{"slug":"/misconceptions/Java/ArrayLengthPartOfType/","name":"ArrayLengthPartOfType","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The length of an array is part of its type"}},{"fields":{"slug":"/misconceptions/Java/ArrayListIsArray/","name":"ArrayListIsArray","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Array","Class"],"shortDescription":"ArrayLists are arrays"}},{"fields":{"slug":"/misconceptions/Java/ArrayRankIsLength/","name":"ArrayRankIsLength","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Array rank and array length are the same thing"}},{"fields":{"slug":"/misconceptions/Java/ArrayRankNotPartOfType/","name":"ArrayRankNotPartOfType","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The rank of an array is not part of its type"}},{"fields":{"slug":"/misconceptions/Java/ArraysGrow/","name":"ArraysGrow","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Array","Allocation"],"shortDescription":"Arrays can grow dynamically"}},{"fields":{"slug":"/misconceptions/Java/AssignCompares/","name":"AssignCompares","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students may use (inadvertently or not) a single  =  operator\nin expressions used as conditions. Th…"}}},"frontmatter":{"status":"public","concepts":["Assignment","Equality","Expression","Operator"],"shortDescription":"= compares two values"}},{"fields":{"slug":"/misconceptions/Java/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Assignment","Variable","Object","Reference"],"shortDescription":"Assignment copies the object"}},{"fields":{"slug":"/misconceptions/Java/AssignmentNotExpression/","name":"AssignmentNotExpression","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Operator","Assignment"],"shortDescription":"An assignment a=b is not an expression"}},{"fields":{"slug":"/misconceptions/Java/BaseCaseNotNeeded/","name":"BaseCaseNotNeeded","pl":"Java","symptoms":{"childMdx":{"excerpt":"It is not clear whether students truly believe that base cases are not needed.\nChances are that the…"}}},"frontmatter":{"status":"draft","concepts":["Recursion","Method","Conditional","Call"],"shortDescription":"Recursive computations do not necessarily need a base case"}},{"fields":{"slug":"/misconceptions/Java/BaseCaseSelfRecursive/","name":"BaseCaseSelfRecursive","pl":"Java","symptoms":{"childMdx":{"excerpt":"In the following example, while the first case is a traditional \"recursive case\", where the next re…"}}},"frontmatter":{"status":"draft","concepts":["Recursion","Method","Call"],"shortDescription":"The base case of a structural recursion consists of a recursive self-call"}},{"fields":{"slug":"/misconceptions/Java/CallNotStaticallyChecked/","name":"CallNotStaticallyChecked","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Method","Call","Class","Subtyping"],"shortDescription":"A method invocation on a reference of a type that does not have that method won't compile"}},{"fields":{"slug":"/misconceptions/Java/CallOnPrimitive/","name":"CallOnPrimitive","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Primitive"],"shortDescription":"One can invoke a method on primitive values"}},{"fields":{"slug":"/misconceptions/Java/CallRequiresVariable/","name":"CallRequiresVariable","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call"],"shortDescription":"One needs a variable to invoke a method"}},{"fields":{"slug":"/misconceptions/Java/CallWithoutFrame/","name":"CallWithoutFrame","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Stack"],"shortDescription":"A method invocation does not necessarily allocate a stack frame"}},{"fields":{"slug":"/misconceptions/Java/CallerFrameContainsCalleeFormal/","name":"CallerFrameContainsCalleeFormal","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Stack","Variable","Parameter"],"shortDescription":"Stack frame of caller includes variables for callee's formal parameters"}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberAccesses/","name":"CannotChainMemberAccesses","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator"],"shortDescription":"Member accesses cannot be chained together"}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberToConstructor/","name":"CannotChainMemberToConstructor","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"shortDescription":"Method calls or field accesses cannot be chained to a constructor invocation"}},{"fields":{"slug":"/misconceptions/Java/CatchAlwaysExecutes/","name":"CatchAlwaysExecutes","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Catch blocks always get executed"}},{"fields":{"slug":"/misconceptions/Java/CatchProvidesOptions/","name":"CatchProvidesOptions","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Only the part of a catch block necessary to fix the cause of an exception is executed"}},{"fields":{"slug":"/misconceptions/Java/ChainedMethodsNotCalledFromOutside/","name":"ChainedMethodsNotCalledFromOutside","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Expression","Object"],"shortDescription":"Chained methods are all called on the object at the beginning of the chain"}},{"fields":{"slug":"/misconceptions/Java/CharNotNumeric/","name":"CharNotNumeric","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Number","String","Type"],"shortDescription":"Char is not a numeric type"}},{"fields":{"slug":"/misconceptions/Java/ComparisonWithBooleanLiteral/","name":"ComparisonWithBooleanLiteral","pl":"Java","symptoms":{"childMdx":{"excerpt":"We observed two kinds of symptoms:\nspecific patterns in code, and specific explanations. Code Patte…"}}},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator","Equality"],"shortDescription":"To test whether an expression is true or false, one must compare it to true or to false"}},{"fields":{"slug":"/misconceptions/Java/CompositeExpressionsUntyped/","name":"CompositeExpressionsUntyped","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Expression"],"shortDescription":"Expressions that consist of multiple parts have no type"}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassMustOverride/","name":"ConcreteClassMustOverride","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Inheritance"],"shortDescription":"A concrete class needs to implement all abstract methods and override all concrete methods declared in its abstract superclasses"}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementClassAbstract/","name":"ConcreteClassOnlyImplementClassAbstract","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from abstract superclasses"}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementDirectAbstract/","name":"ConcreteClassOnlyImplementDirectAbstract","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement abstract methods declared in its direct supertypes"}},{"fields":{"slug":"/misconceptions/Java/ConcreteClassOnlyImplementInterfaceAbstract/","name":"ConcreteClassOnlyImplementInterfaceAbstract","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Subtyping","Inheritance"],"shortDescription":"A concrete class only needs to implement those abstract methods it inherits from interfaces"}},{"fields":{"slug":"/misconceptions/Java/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception can be detected by asking students to draw\na control-flow graph of a sequence of…"}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-else is equivalent to sequence of two ifs"}},{"fields":{"slug":"/misconceptions/Java/ConstructorAllocates/","name":"ConstructorAllocates","pl":"Java","symptoms":{"childMdx":{"excerpt":"Here is an example occurrence of this misconception,\nwhen students had to create a \"wrapper\" class …"}}},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call"],"shortDescription":"The constructor allocates the object"}},{"fields":{"slug":"/misconceptions/Java/ConstructorParameterIsField/","name":"ConstructorParameterIsField","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Constructor","Parameter","Field"],"shortDescription":"Formal constructor parameters are equivalent to instance variables"}},{"fields":{"slug":"/misconceptions/Java/ConstructorReturnsObject/","name":"ConstructorReturnsObject","pl":"Java","symptoms":{"childMdx":{"excerpt":"Do your students write: Constructors that  return this Constructors (of a class C) that  return new…"}}},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Return"],"shortDescription":"Constructors need to return objects"}},{"fields":{"slug":"/misconceptions/Java/ConstructorWithoutNew/","name":"ConstructorWithoutNew","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Constructor","Call","Allocation"],"shortDescription":"One can write the constructor name, without new, to instantiate a class"}},{"fields":{"slug":"/misconceptions/Java/ControlledLocalAccess/","name":"ControlledLocalAccess","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception is directly visible in code.\nHere is an example occurrence from a Java course. I…"}}},"frontmatter":{"status":"public","concepts":["Variable","Scope","Lifetime","AccessModifier"],"shortDescription":"One can control access to local variables using access modifiers"}},{"fields":{"slug":"/misconceptions/Java/DeferredReturn/","name":"DeferredReturn","pl":"Java","symptoms":null},"frontmatter":{"status":"public","concepts":["Return","ControlFlow","Method","Call"],"shortDescription":"A return statement in the middle of a method doesn't return immediately"}},{"fields":{"slug":"/misconceptions/Java/ElsIf/","name":"ElsIf","pl":"Java","symptoms":{"childMdx":{"excerpt":"Other programming languages feature an \"elsif\" construct (e.g.,  elif  in Python) that allows chain…"}}},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"There is an elsif keyword for multi-way conditional statements"}},{"fields":{"slug":"/misconceptions/Java/ElseAlwaysExecutes/","name":"ElseAlwaysExecutes","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"The else branch of an if-else statement always executes"}},{"fields":{"slug":"/misconceptions/Java/EqualityOperatorComparesObjectsValues/","name":"EqualityOperatorComparesObjectsValues","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students use the  ==  operator to compare objects' state. They don't know the existence of an  equa…"}}},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Operator","Expression"],"shortDescription":"o==p compares the objects referred to by variables o and p"}},{"fields":{"slug":"/misconceptions/Java/EqualsComparesReferences/","name":"EqualsComparesReferences","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Method","Expression"],"shortDescription":"o.equals(p) compares the references stored in the variables o and p"}},{"fields":{"slug":"/misconceptions/Java/EvaluationResultsArePrinted/","name":"EvaluationResultsArePrinted","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Evaluation","Output"],"shortDescription":"Evaluating an expression means outputting its result"}},{"fields":{"slug":"/misconceptions/Java/ExceptionRoot/","name":"ExceptionRoot","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","Subtyping"],"shortDescription":"Exception is the top-most exception class"}},{"fields":{"slug":"/misconceptions/Java/ExpressionAssigns/","name":"ExpressionAssigns","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Expression","Assignment","Variable"],"shortDescription":"An expression that reads a variable also updates its value after the evaluation"}},{"fields":{"slug":"/misconceptions/Java/ExpressionsDynamicallyTyped/","name":"ExpressionsDynamicallyTyped","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Evaluation","Expression","Value","Type"],"shortDescription":"One has to evaluate an expression to determine its type"}},{"fields":{"slug":"/misconceptions/Java/FinalReferenceImpliesImmutability/","name":"FinalReferenceImpliesImmutability","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Mutability","Reference"],"shortDescription":"An object referred to by a final variable is an immutable object"}},{"fields":{"slug":"/misconceptions/Java/ForEachIteratesOverIndices/","name":"ForEachIteratesOverIndices","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Array"],"shortDescription":"An enhanced for loop iterates over the indices of an array or a collection"}},{"fields":{"slug":"/misconceptions/Java/ForEachTraversesRecursiveStructure/","name":"ForEachTraversesRecursiveStructure","pl":"Java","symptoms":{"childMdx":{"excerpt":"Here, the student believes that the for-each loop will traverse all nodes making up a list: The fol…"}}},"frontmatter":{"status":"draft","concepts":["Loop","Recursion"],"shortDescription":"For-each loops know how to traverse any recursive data structure"}},{"fields":{"slug":"/misconceptions/Java/ForEachVariableIsElement/","name":"ForEachVariableIsElement","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Array"],"shortDescription":"One can assign to the variable of an enhanced for statement to store a value in the corresponding array or collection element"}},{"fields":{"slug":"/misconceptions/Java/ForIsConditional/","name":"ForIsConditional","pl":"Java","symptoms":{"childMdx":{"excerpt":"Here is an example of a symptom that might indicate this misconception\n(for a  while  instead of a …"}}},"frontmatter":{"status":"draft","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of a for statement executes at most once"}},{"fields":{"slug":"/misconceptions/Java/ForVariableScopeBeyondLoop/","name":"ForVariableScopeBeyondLoop","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception shows up when students\nneed to write multiple loops in a method, like this: Stud…"}}},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Scope"],"shortDescription":"The scope of variables declared in a for loop header extends beyond the loop"}},{"fields":{"slug":"/misconceptions/Java/FrameIsClassInstance/","name":"FrameIsClassInstance","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Stack","Object","Call"],"shortDescription":"A stack frame is the same as an instance of a class"}},{"fields":{"slug":"/misconceptions/Java/IfIsLoop/","name":"IfIsLoop","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students claim an  if -statement means \"ensure that this condition holds\" Students claim an  if -st…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of an if statement executes repeatedly, as long as the condition holds"}},{"fields":{"slug":"/misconceptions/Java/IfRequiresElse/","name":"IfRequiresElse","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Conditional","ControlFlow"],"shortDescription":"Every if statement requires an else"}},{"fields":{"slug":"/misconceptions/Java/ImmutableRequiresFinalParameters/","name":"ImmutableRequiresFinalParameters","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Mutability","Class","Constructor","Method","Parameter"],"shortDescription":"Immutable classes need final constructor/method parameters"}},{"fields":{"slug":"/misconceptions/Java/ImplicitInterfaceImplementation/","name":"ImplicitInterfaceImplementation","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Inheritance"],"shortDescription":"Java implicitly produces implementations of any methods a class inherits from the interfaces it implements"}},{"fields":{"slug":"/misconceptions/Java/IntegerDivisionToRational/","name":"IntegerDivisionToRational","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Number","Type"],"shortDescription":"Dividing two integers can produce a rational number"}},{"fields":{"slug":"/misconceptions/Java/InterfaceExtendClass/","name":"InterfaceExtendClass","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Subtyping","Inheritance"],"shortDescription":"An interface can extend a class"}},{"fields":{"slug":"/misconceptions/Java/LargeIntegerLong/","name":"LargeIntegerLong","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Literal","Number","Type","Expression"],"shortDescription":"Large integer numbers have type long"}},{"fields":{"slug":"/misconceptions/Java/LiteralNoExpression/","name":"LiteralNoExpression","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Literal","Expression"],"shortDescription":"A literal is not an expression"}},{"fields":{"slug":"/misconceptions/Java/LiteralString/","name":"LiteralString","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Literal","String","Argument"],"shortDescription":"When passing a literal string as argument to a method, no quotes are needed"}},{"fields":{"slug":"/misconceptions/Java/LocalVariablesAutoInitialized/","name":"LocalVariablesAutoInitialized","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Variable","Value","Assignment"],"shortDescription":"Local variables are automatically initialized"}},{"fields":{"slug":"/misconceptions/Java/LoopBodyScopeImpliesLoopLifetime/","name":"LoopBodyScopeImpliesLoopLifetime","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students with this misconception may declare an accumulator variable\ninside the loop body, like thi…"}}},"frontmatter":{"status":"draft","concepts":["Loop","Variable","Lifetime","Scope"],"shortDescription":"Lifetime of variables declared in a loop body extends across all loop iterations"}},{"fields":{"slug":"/misconceptions/Java/LoopTerminatingCondition/","name":"LoopTerminatingCondition","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Loop","Conditional","ControlFlow"],"shortDescription":"For and while loops end when the condition becomes true"}},{"fields":{"slug":"/misconceptions/Java/MapToBooleanWithConditionalOperator/","name":"MapToBooleanWithConditionalOperator","pl":"Java","symptoms":{"childMdx":{"excerpt":"In the following examples,\nassume that  CONDITION  is some expression of type  boolean \n(e.g.,  isH…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Expression","Operator","Boolean"],"shortDescription":"To map a boolean expression to a boolean, a conditional operator is necessary"}},{"fields":{"slug":"/misconceptions/Java/MapToBooleanWithIf/","name":"MapToBooleanWithIf","pl":"Java","symptoms":{"childMdx":{"excerpt":"In the following examples,\nassume that  CONDITION  is some expression of type  boolean \n(e.g.,  isH…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Statement","Boolean"],"shortDescription":"To map a boolean expression to a boolean, an if statement is necessary"}},{"fields":{"slug":"/misconceptions/Java/MethodAsField/","name":"MethodAsField","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Field","Object","Class"],"shortDescription":"Each object contains its own special fields for all of its methods"}},{"fields":{"slug":"/misconceptions/Java/MethodWithoutReturnType/","name":"MethodWithoutReturnType","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Type"],"shortDescription":"A method declaration does not need to include a return type"}},{"fields":{"slug":"/misconceptions/Java/MethodsWithoutClass/","name":"MethodsWithoutClass","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Class"],"shortDescription":"Methods can be defined outside a class"}},{"fields":{"slug":"/misconceptions/Java/MultiReferenceVariable/","name":"MultiReferenceVariable","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Reference","Variable","Object"],"shortDescription":"A reference variable can point to multiple objects"}},{"fields":{"slug":"/misconceptions/Java/MultiValueVariable/","name":"MultiValueVariable","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Variable","Value"],"shortDescription":"A variable can contain more than one value"}},{"fields":{"slug":"/misconceptions/Java/MultidimensionalArray/","name":"MultidimensionalArray","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"A multi-dimensional array is one single array object"}},{"fields":{"slug":"/misconceptions/Java/MultipleSuperclasses/","name":"MultipleSuperclasses","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Subtyping"],"shortDescription":"A class can have multiple superclasses"}},{"fields":{"slug":"/misconceptions/Java/MustInitializeFieldInConstructor/","name":"MustInitializeFieldInConstructor","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Assignment","Constructor","Field","Value","Variable"],"shortDescription":"Constructors must assign values to all fields"}},{"fields":{"slug":"/misconceptions/Java/NamedTypeParameter/","name":"NamedTypeParameter","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Parameter","Name"],"shortDescription":"To instantiate a generic type, for each type parameter one has to specify both the name and the type"}},{"fields":{"slug":"/misconceptions/Java/NestedObjectsImplyNestedClasses/","name":"NestedObjectsImplyNestedClasses","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Object"],"shortDescription":"If objects are part of a containment hierarchy, their classes are nested, too"}},{"fields":{"slug":"/misconceptions/Java/NestedPackages/","name":"NestedPackages","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Member"],"shortDescription":"Packages can contain other packages which have access to members of the containing package"}},{"fields":{"slug":"/misconceptions/Java/NoAtomicExpression/","name":"NoAtomicExpression","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece"}},{"fields":{"slug":"/misconceptions/Java/NoCallOnStringLiteral/","name":"NoCallOnStringLiteral","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","String","Literal"],"shortDescription":"One cannot invoke methods on String literals"}},{"fields":{"slug":"/misconceptions/Java/NoCastIfSameSize/","name":"NoCastIfSameSize","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Variable","Value","Number","Type"],"shortDescription":"If a variable is at least as big (bit-width) as a value, then no cast is needed to a assign the value to the variable"}},{"fields":{"slug":"/misconceptions/Java/NoCharEscape/","name":"NoCharEscape","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Literal"],"shortDescription":"\\ is a normal character in char and String literals"}},{"fields":{"slug":"/misconceptions/Java/NoEmptyConstructor/","name":"NoEmptyConstructor","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Constructor"],"shortDescription":"A constructor must do something"}},{"fields":{"slug":"/misconceptions/Java/NoFieldInheritance/","name":"NoFieldInheritance","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Object","Class","Field"],"shortDescription":"An object contains only the fields declared in its class"}},{"fields":{"slug":"/misconceptions/Java/NoFieldlessObjects/","name":"NoFieldlessObjects","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Object","Field"],"shortDescription":"Objects without instance variables can't exist"}},{"fields":{"slug":"/misconceptions/Java/NoFloatLiterals/","name":"NoFloatLiterals","pl":"Java","symptoms":{"childMdx":{"excerpt":"The following code snippet shows how this misconception can manifest itself:"}}},"frontmatter":{"status":"public","concepts":["Literal","Number","Type"],"shortDescription":"There are no float literals"}},{"fields":{"slug":"/misconceptions/Java/NoImplicitWidening/","name":"NoImplicitWidening","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type"],"shortDescription":"Smaller types are never automatically converted into bigger ones without an explicit cast"}},{"fields":{"slug":"/misconceptions/Java/NoInsideMethodCallInConstructor/","name":"NoInsideMethodCallInConstructor","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Constructor","Object"],"shortDescription":"It is foirbidden to call other methods on the same object while inside its constructor"}},{"fields":{"slug":"/misconceptions/Java/NoJaggedArrays/","name":"NoJaggedArrays","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Multi-dimensional arrays have a rectangular shape"}},{"fields":{"slug":"/misconceptions/Java/NoLocalVariables/","name":"NoLocalVariables","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Variable","Stack"],"shortDescription":"There are no local variables"}},{"fields":{"slug":"/misconceptions/Java/NoLongLiterals/","name":"NoLongLiterals","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Literal","Number","Type"],"shortDescription":"There are no long literals"}},{"fields":{"slug":"/misconceptions/Java/NoMethodInheritance/","name":"NoMethodInheritance","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Inheritance","Field","Method","Class"],"shortDescription":"Subclasses inherit fields but not methods"}},{"fields":{"slug":"/misconceptions/Java/NoReservedWords/","name":"NoReservedWords","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Name"],"shortDescription":"Every sequence of letters and digits starting with a letter can be used as an identifier"}},{"fields":{"slug":"/misconceptions/Java/NoShortCircuit/","name":"NoShortCircuit","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception can be observed in cases where the operands cause side effects:"}}},"frontmatter":{"status":"public","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"shortDescription":"&& and || always evaluate both operands"}},{"fields":{"slug":"/misconceptions/Java/NoSingleLogicAnd/","name":"NoSingleLogicAnd","pl":"Java","symptoms":{"childMdx":{"excerpt":"If students claim that  &  is \"bitwise and\" (for  int )\nand  &&  is \"logical and\" (for  boolean ),\n…"}}},"frontmatter":{"status":"public","concepts":["Operator","Boolean"],"shortDescription":"& is only a bitwise AND"}},{"fields":{"slug":"/misconceptions/Java/NoStringToString/","name":"NoStringToString","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Method","Call"],"shortDescription":"One cannot invoke toString() on a String"}},{"fields":{"slug":"/misconceptions/Java/NullIsObject/","name":"NullIsObject","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Reference","Object","Null","Literal","Value"],"shortDescription":"null is an object"}},{"fields":{"slug":"/misconceptions/Java/NullPointerExceptionCompileTime/","name":"NullPointerExceptionCompileTime","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception"],"shortDescription":"NullPointerExceptions are detected at compile time"}},{"fields":{"slug":"/misconceptions/Java/NumericToBooleanCoercion/","name":"NumericToBooleanCoercion","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Number","Type","Boolean"],"shortDescription":"Numeric types can be coerced to boolean"}},{"fields":{"slug":"/misconceptions/Java/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students may: not accept  new Object()  as a legal expression say  new SomeAbstractClass();  (where…"}}},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Expression","Name"],"shortDescription":"A variable is needed to instantiate an object"}},{"fields":{"slug":"/misconceptions/Java/OnlyInnermostArrayElements/","name":"OnlyInnermostArrayElements","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array"],"shortDescription":"Only the elements of the innermost array of a multi-dimensional array are accessible"}},{"fields":{"slug":"/misconceptions/Java/OutOfBoundsElementsAreNull/","name":"OutOfBoundsElementsAreNull","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Null"],"shortDescription":"Out-of-bounds array elements are null"}},{"fields":{"slug":"/misconceptions/Java/OutsideInMethodNesting/","name":"OutsideInMethodNesting","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception occurred quite regularly, even for strong students.\nHere are two diagnostic prob…"}}},"frontmatter":{"status":"public","concepts":["Method","Call","Expression","Function","Composition"],"shortDescription":"Nested method calls are invoked outside in"}},{"fields":{"slug":"/misconceptions/Java/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument","pl":"Java","symptoms":{"childMdx":{"excerpt":"A student may write code like this:"}}},"frontmatter":{"status":"public","concepts":["Method","Call","Expression"],"shortDescription":"() are optional for method calls without arguments"}},{"fields":{"slug":"/misconceptions/Java/PreIncrementBeforeLoop/","name":"PreIncrementBeforeLoop","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Operator","Loop","ControlFlow"],"shortDescription":"Pre-increment in update part of for loop means increment before loop body"}},{"fields":{"slug":"/misconceptions/Java/PrimitiveIsObject/","name":"PrimitiveIsObject","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Primitive","Value","Object"],"shortDescription":"Primitive values are heap objects"}},{"fields":{"slug":"/misconceptions/Java/PrimitiveTypeParameter/","name":"PrimitiveTypeParameter","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Parameter","Primitive"],"shortDescription":"Type parameters of generic types can be instantiated with primitive types"}},{"fields":{"slug":"/misconceptions/Java/PrimitiveVariablesDynamicallyTyped/","name":"PrimitiveVariablesDynamicallyTyped","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Value"],"shortDescription":"The type of a primitive variable depends on its value"}},{"fields":{"slug":"/misconceptions/Java/PrivateAccessibleInSubclass/","name":"PrivateAccessibleInSubclass","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Member","Field","Method","Inheritance"],"shortDescription":"Private members of a superclass are accessible from a subclass"}},{"fields":{"slug":"/misconceptions/Java/PrivateFieldsImplyImmutability/","name":"PrivateFieldsImplyImmutability","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Mutability","Class","Field","AccessModifier"],"shortDescription":"A class where all fields are private is immutable"}},{"fields":{"slug":"/misconceptions/Java/PrivateFromOtherInstance/","name":"PrivateFromOtherInstance","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students call a getter method on other objects of the same class."}}},"frontmatter":{"status":"public","concepts":["AccessModifier","Member"],"shortDescription":"An object cannot access private members of other objects of the same class"}},{"fields":{"slug":"/misconceptions/Java/PrivateFromStatic/","name":"PrivateFromStatic","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["AccessModifier","Member","Static"],"shortDescription":"Static methods cannot access private members of instances of same class"}},{"fields":{"slug":"/misconceptions/Java/PrivateMeansFinal/","name":"PrivateMeansFinal","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Mutability","Field","AccessModifier"],"shortDescription":"A private field cannot be changed"}},{"fields":{"slug":"/misconceptions/Java/RationalLiterals/","name":"RationalLiterals","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Number","Literal"],"shortDescription":"Rational fractions are literals"}},{"fields":{"slug":"/misconceptions/Java/RecursiveActivationsShareFrame/","name":"RecursiveActivationsShareFrame","pl":"Java","symptoms":{"childMdx":{"excerpt":"The following examples show possible symptoms of this misconception: In the following example,\n max…"}}},"frontmatter":{"status":"public","concepts":["Recursion","Stack"],"shortDescription":"Recursive calls of a method share a stack frame"}},{"fields":{"slug":"/misconceptions/Java/RecursiveCallSiteNoReturn/","name":"RecursiveCallSiteNoReturn","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Recursion","Call"],"shortDescription":"Tail-recursive call sites of non-void methods need no return statement"}},{"fields":{"slug":"/misconceptions/Java/RecursiveMethodImpliesRecursiveType/","name":"RecursiveMethodImpliesRecursiveType","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Recursion","Method","Type"],"shortDescription":"A class with a recursive method represents part of a recursive data structure"}},{"fields":{"slug":"/misconceptions/Java/RecursiveMethodNeedsIfElse/","name":"RecursiveMethodNeedsIfElse","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Recursion","Method","Conditional","ControlFlow"],"shortDescription":"A recursive method needs to contain an if-else statement"}},{"fields":{"slug":"/misconceptions/Java/ReferenceIntoStack/","name":"ReferenceIntoStack","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Reference","Stack"],"shortDescription":"References can point into the stack"}},{"fields":{"slug":"/misconceptions/Java/ReferenceToBooleanCoercion/","name":"ReferenceToBooleanCoercion","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception may surface especially in the context of conditionals. In the following code, th…"}}},"frontmatter":{"status":"draft","concepts":["Reference","Type","Boolean"],"shortDescription":"Every reference type can be coerced to boolean"}},{"fields":{"slug":"/misconceptions/Java/ReferenceToIntegerConversion/","name":"ReferenceToIntegerConversion","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Reference","Type","Number"],"shortDescription":"One can cast between references and ints"}},{"fields":{"slug":"/misconceptions/Java/ReferenceToVariable/","name":"ReferenceToVariable","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Reference","Variable"],"shortDescription":"References can point to variables"}},{"fields":{"slug":"/misconceptions/Java/ReferringToRecursiveStructureMakesRecursive/","name":"ReferringToRecursiveStructureMakesRecursive","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Recursion"],"shortDescription":"A class referring to a recursive data structure is (indirectly) part of that recursion as well"}},{"fields":{"slug":"/misconceptions/Java/ReturnCall/","name":"ReturnCall","pl":"Java","symptoms":{"childMdx":{"excerpt":"The following example shows an occurrence of this misconception\nwhere only one of the three  return…"}}},"frontmatter":{"status":"public","concepts":["Return","Method","Call"],"shortDescription":"Return statements need () around the return value"}},{"fields":{"slug":"/misconceptions/Java/ReturnUnwindsMultipleFrames/","name":"ReturnUnwindsMultipleFrames","pl":"Java","symptoms":{"childMdx":{"excerpt":"A good way to detect this misconception is through the use\nof (UML-like) sequence diagrams.\nIf the …"}}},"frontmatter":{"status":"public","concepts":["Call","Return","Stack","Recursion"],"shortDescription":"A return statement can unwind multiple call stack frames"}},{"fields":{"slug":"/misconceptions/Java/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Java","symptoms":{"childMdx":{"excerpt":"This misconception can manifest itself when drawing expression trees,\ne.g., the tree for  a().b() ,…"}}},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator","Associativity"],"shortDescription":"Chained accesses are invoked from right to left"}},{"fields":{"slug":"/misconceptions/Java/RuntimeExceptionChecked/","name":"RuntimeExceptionChecked","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","Subtyping"],"shortDescription":"RuntimeExceptions are checked exceptions"}},{"fields":{"slug":"/misconceptions/Java/SingleQuoteString/","name":"SingleQuoteString","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students may liberally use single quotes to delimit  String  literals, as they would in other progr…"}}},"frontmatter":{"status":"draft","concepts":["String","Literal"],"shortDescription":"String literals can be in single quotes"}},{"fields":{"slug":"/misconceptions/Java/StackTraceIsCallHistory/","name":"StackTraceIsCallHistory","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Stack","Method","Call"],"shortDescription":"A stack trace is the sequence of previously called methods"}},{"fields":{"slug":"/misconceptions/Java/StaticCallPolymorphic/","name":"StaticCallPolymorphic","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Call","Polymorphism","Parameter","Type"],"shortDescription":"A static method call is dispatched polymorphically at runtime based on the argument types"}},{"fields":{"slug":"/misconceptions/Java/StaticDispatch/","name":"StaticDispatch","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Inheritance","Method","Call","Subtyping"],"shortDescription":"The method to be called is determined by the static type"}},{"fields":{"slug":"/misconceptions/Java/StringLengthField/","name":"StringLengthField","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Field","Method"],"shortDescription":"One can know the length of a String object by accessing its length field"}},{"fields":{"slug":"/misconceptions/Java/StringLiteralNoObject/","name":"StringLiteralNoObject","pl":"Java","symptoms":{"childMdx":{"excerpt":"Novice students may write code like this:"}}},"frontmatter":{"status":"public","concepts":["Literal","String"],"shortDescription":"One needs to call the String constructor to get a String object from a literal"}},{"fields":{"slug":"/misconceptions/Java/StringPlusStringifiesExpression/","name":"StringPlusStringifiesExpression","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["String","Expression","Operator"],"shortDescription":"String concatenation stringifies non-String operand expressions"}},{"fields":{"slug":"/misconceptions/Java/StringRepetitionOperator/","name":"StringRepetitionOperator","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Number","Repetition"],"shortDescription":"The multiplication operator can repeat a String a number of times"}},{"fields":{"slug":"/misconceptions/Java/SubtypeCompatibleWithSupertype/","name":"SubtypeCompatibleWithSupertype","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Subtyping","Type","Inheritance","Reference"],"shortDescription":"A variable of a subtype can reference an object of a supertype"}},{"fields":{"slug":"/misconceptions/Java/SuperAlwaysHasParentheses/","name":"SuperAlwaysHasParentheses","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Call","Inheritance"],"shortDescription":"To call a method on a superclass, parentheses are needed after the keyword super"}},{"fields":{"slug":"/misconceptions/Java/SuperNotFirstStatement/","name":"SuperNotFirstStatement","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Inheritance","Call"],"shortDescription":"super() can be called anywhere in the constructor of a subclass"}},{"fields":{"slug":"/misconceptions/Java/SuperclassObjectAllocated/","name":"SuperclassObjectAllocated","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Allocation","Class","Object","Inheritance"],"shortDescription":"When instantiating an object of a subclass, an object of a superclass is also allocated"}},{"fields":{"slug":"/misconceptions/Java/SupertypeIncompatibleWithSubtype/","name":"SupertypeIncompatibleWithSubtype","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Inheritance","Subtyping","Type","Reference"],"shortDescription":"A variable of a supertype cannot reference an object of a subtype"}},{"fields":{"slug":"/misconceptions/Java/TargetTyping/","name":"TargetTyping","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Number","Expression"],"shortDescription":"The type of a numerical expression depends on the type expected by the surrounding context"}},{"fields":{"slug":"/misconceptions/Java/ThisAsField/","name":"ThisAsField","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Field","Variable","Reference","Object","Self"],"shortDescription":"this is a special field in the object"}},{"fields":{"slug":"/misconceptions/Java/ThisAssignable/","name":"ThisAssignable","pl":"Java","symptoms":{"childMdx":{"excerpt":"We have observed this misconception in constructors\nand in recursive traversals over recursive data…"}}},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"One can assign to this"}},{"fields":{"slug":"/misconceptions/Java/ThisCanBeNull/","name":"ThisCanBeNull","pl":"Java","symptoms":{"childMdx":{"excerpt":"The following question from a paper-based exam\nlead to a considerable number of student submissions…"}}},"frontmatter":{"status":"public","concepts":["Null","Reference","Self"],"shortDescription":"this can be null"}},{"fields":{"slug":"/misconceptions/Java/ThisExistsInStaticMethod/","name":"ThisExistsInStaticMethod","pl":"Java","symptoms":{"childMdx":{"excerpt":"When drawing stack frames of static methods, students include  this"}}},"frontmatter":{"status":"public","concepts":["Variable","Reference","Object","Static","Method","Self"],"shortDescription":"this is a local variable, also in static methods"}},{"fields":{"slug":"/misconceptions/Java/ThisInConstructorIsNull/","name":"ThisInConstructorIsNull","pl":"Java","symptoms":{"childMdx":{"excerpt":"The following exam question,\nwhile having the goal of checking whether students understand\nthat con…"}}},"frontmatter":{"status":"draft","concepts":["Constructor","Null","Reference","Self"],"shortDescription":"In a constructor, this is null"}},{"fields":{"slug":"/misconceptions/Java/ThisNoExpression/","name":"ThisNoExpression","pl":"Java","symptoms":{"childMdx":{"excerpt":"Students may believe that  this  on its own doesn't have any meaning.\nThey might express statements…"}}},"frontmatter":{"status":"public","concepts":["Expression","Self"],"shortDescription":"The name this is not an expression"}},{"fields":{"slug":"/misconceptions/Java/ToStringPrints/","name":"ToStringPrints","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","String","Output","Evaluation"],"shortDescription":"Invoking toString() prints something"}},{"fields":{"slug":"/misconceptions/Java/TryCatchMandatory/","name":"TryCatchMandatory","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"When a piece of code can throw an exception, it must be surrounded with a try/catch block"}},{"fields":{"slug":"/misconceptions/Java/TryFinishes/","name":"TryFinishes","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","ControlFlow"],"shortDescription":"Exceptions get thrown at the end of the try block"}},{"fields":{"slug":"/misconceptions/Java/UndeclaredVariables/","name":"UndeclaredVariables","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Variable"],"shortDescription":"Variables can be used even without being declared beforehand"}},{"fields":{"slug":"/misconceptions/Java/UnqualifiedNamesMustDiffer/","name":"UnqualifiedNamesMustDiffer","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Name","Class","Scope"],"shortDescription":"The unqualified names of different classes must be different"}},{"fields":{"slug":"/misconceptions/Java/UntypedVariables/","name":"UntypedVariables","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Variable","Type"],"shortDescription":"Variable declarations don't need a type"}},{"fields":{"slug":"/misconceptions/Java/UseOfSelfTypeImpliesRecursiveType/","name":"UseOfSelfTypeImpliesRecursiveType","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Class","Method","Variable","Parameter","Return","Value","Type","Recursion"],"shortDescription":"If a class has a method that has a local variable, parameter, or return value with the class as its type, the class is a recursive type"}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldExpressions/","name":"VariablesHoldExpressions","pl":"Java","symptoms":{"childMdx":{"excerpt":"A student holding this misconception may put the expression\n(not its value) into the box of a memor…"}}},"frontmatter":{"status":"public","concepts":["Variable","Expression","Assignment"],"shortDescription":"= stores an expression in a variable"}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldObjects/","name":"VariablesHoldObjects","pl":"Java","symptoms":{"childMdx":{"excerpt":"A common symptom of this misconception is the special case\nwhere students draw diagrams of memory\na…"}}},"frontmatter":{"status":"public","concepts":["Variable","Object","Reference"],"shortDescription":"A variable of a reference type contains a whole object"}},{"fields":{"slug":"/misconceptions/Java/VoidMethodNotRecursive/","name":"VoidMethodNotRecursive","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Type","Recursion"],"shortDescription":"A method with void return type can't be recursive"}},{"fields":{"slug":"/misconceptions/Java/VoidMethodReturnsValue/","name":"VoidMethodReturnsValue","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Method","Type","Return","Value"],"shortDescription":"A method with void return type can return a value"}},{"fields":{"slug":"/misconceptions/Java/ZeroDigitsCompress/","name":"ZeroDigitsCompress","pl":"Java","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Number"],"shortDescription":"In integer numbers, decimal digits with value `0` take less storage than decimal digits with other values"}},{"fields":{"slug":"/misconceptions/JavaScript/AccessingInexistentPropertyError/","name":"AccessingInexistentPropertyError","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Exception","Field","Member","Object","Undefined"],"shortDescription":"Accessing a non existent property on an object produces an error"}},{"fields":{"slug":"/misconceptions/JavaScript/ArrowFunctionNoImpliedReturn/","name":"ArrowFunctionNoImpliedReturn","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Return","Expression","Function"],"shortDescription":"Even when an arrow function consists just of an expression, the return keyword must be explicitly written"}},{"fields":{"slug":"/misconceptions/JavaScript/ArrowFunctionRequiresFunctionKeyword/","name":"ArrowFunctionRequiresFunctionKeyword","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Expression"],"shortDescription":"Arrow functions also require the keyword 'function'"}},{"fields":{"slug":"/misconceptions/JavaScript/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Assignment","Variable","Object","Reference"],"shortDescription":"Assignment copies the object"}},{"fields":{"slug":"/misconceptions/JavaScript/CallbackParametersInCaller/","name":"CallbackParametersInCaller","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":"Many functions in JavaScript are higher-order functions\nthat accept \"callback\" functions as argumen…"}}},"frontmatter":{"status":"draft","concepts":["Argument","Parameter","Function","Value","Call"],"shortDescription":"Parameters of a callback function may be written as parameters of the caller function"}},{"fields":{"slug":"/misconceptions/JavaScript/CharType/","name":"CharType","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Type"],"shortDescription":"A single character is of type char"}},{"fields":{"slug":"/misconceptions/JavaScript/ClassDefinesType/","name":"ClassDefinesType","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Class","Type"],"shortDescription":"The type of an object is equivalent to the type defined by its class definition"}},{"fields":{"slug":"/misconceptions/JavaScript/ConditionalOperatorNotExpression/","name":"ConditionalOperatorNotExpression","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Expression","Operator","Conditional","ControlFlow"],"shortDescription":"The conditional operator is not an expression"}},{"fields":{"slug":"/misconceptions/JavaScript/ConstDeclarationCanBeLeftUninitialized/","name":"ConstDeclarationCanBeLeftUninitialized","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Assignment","Variable"],"shortDescription":"Declarations of constants do not need to be immediately initialized"}},{"fields":{"slug":"/misconceptions/JavaScript/ConstReferenceImpliesImmutability/","name":"ConstReferenceImpliesImmutability","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":"Watch a real student who might have this misconception solving a programming exercise!"}}},"frontmatter":{"status":"public","concepts":["Mutability","Reference"],"shortDescription":"An object referred to by a const variable is an immutable object"}},{"fields":{"slug":"/misconceptions/JavaScript/EqualityOperatorComparesObjectsValues/","name":"EqualityOperatorComparesObjectsValues","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Equality","Object","Operator","Reference","Value"],"shortDescription":"The equality operator compares two objects' values"}},{"fields":{"slug":"/misconceptions/JavaScript/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Operator","Equality","Type","Value"],"shortDescription":"The equality operator '==' compares only the types of the operands"}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionAsValueWithParentheses/","name":"FunctionAsValueWithParentheses","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Value","Call"],"shortDescription":"To use a function as a value, one needs to have parentheses after its name"}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionOverloading/","name":"FunctionOverloading","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Argument","Parameter"],"shortDescription":"It is possible to create multiple functions with the same name but with different signatures"}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionsCannotBeImmediatelyInvoked/","name":"FunctionsCannotBeImmediatelyInvoked","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Call","Scope"],"shortDescription":"Functions cannot be called in the expression in which they are defined"}},{"fields":{"slug":"/misconceptions/JavaScript/FunctionsMustBeNamed/","name":"FunctionsMustBeNamed","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Name","Scope"],"shortDescription":"Every function definition requires an associated name"}},{"fields":{"slug":"/misconceptions/JavaScript/IdentifierAsStringInBracketNotation/","name":"IdentifierAsStringInBracketNotation","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Expression","String","Field","Object"],"shortDescription":"An identifier used to access a property with the bracket notation is treated as a string"}},{"fields":{"slug":"/misconceptions/JavaScript/MandatoryAssignment/","name":"MandatoryAssignment","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Assignment","Expression","Statement"],"shortDescription":"An expression must be assigned to have a valid statement"}},{"fields":{"slug":"/misconceptions/JavaScript/MapInPlace/","name":"MapInPlace","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Return"],"shortDescription":"Map modifies the elements of the array on which it operates in place"}},{"fields":{"slug":"/misconceptions/JavaScript/NoAtomicExpression/","name":"NoAtomicExpression","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece"}},{"fields":{"slug":"/misconceptions/JavaScript/NoBracketNotationForObjects/","name":"NoBracketNotationForObjects","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Object","Field"],"shortDescription":"Square brackets cannot be used to access properties of an object"}},{"fields":{"slug":"/misconceptions/JavaScript/NoFunctionCallsChaining/","name":"NoFunctionCallsChaining","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Expression","Call","Function","Precedence"],"shortDescription":"It is not allowed to chain function calls"}},{"fields":{"slug":"/misconceptions/JavaScript/NoGlobalObject/","name":"NoGlobalObject","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Object","Scope"],"shortDescription":"There isn't a global object"}},{"fields":{"slug":"/misconceptions/JavaScript/NoReturnValue/","name":"NoReturnValue","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Undefined","Return","Value"],"shortDescription":"Functions without return statements return no value at all"}},{"fields":{"slug":"/misconceptions/JavaScript/NullAndUndefinedAreTheSame/","name":"NullAndUndefinedAreTheSame","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Type","Value","Equality","Null","Undefined"],"shortDescription":"The values null and undefined are the same"}},{"fields":{"slug":"/misconceptions/JavaScript/NullIsObject/","name":"NullIsObject","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":"Watch a real student who might have this misconception solving a programming exercise!"}}},"frontmatter":{"status":"public","concepts":["Null","Object","Reference","Value","Literal"],"shortDescription":"null is an object"}},{"fields":{"slug":"/misconceptions/JavaScript/NumberOfParametersMatchArguments/","name":"NumberOfParametersMatchArguments","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Function","Call","Argument","Parameter"],"shortDescription":"Functions must be called with the same number of arguments as defined in their signature"}},{"fields":{"slug":"/misconceptions/JavaScript/ObjectAsParameterIsCopied/","name":"ObjectAsParameterIsCopied","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Argument","Parameter","Object","Reference"],"shortDescription":"Objects are passed by value"}},{"fields":{"slug":"/misconceptions/JavaScript/PrototypesAreClasses/","name":"PrototypesAreClasses","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Prototype","Class"],"shortDescription":"JavaScript is based on a class-based object model"}},{"fields":{"slug":"/misconceptions/JavaScript/StringRepetitionOperator/","name":"StringRepetitionOperator","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Number","Repetition"],"shortDescription":"One can repeat a String by multiplying it with a number"}},{"fields":{"slug":"/misconceptions/JavaScript/ThisAssignable/","name":"ThisAssignable","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"One can assign to this"}},{"fields":{"slug":"/misconceptions/JavaScript/TypeofArrayIsArray/","name":"TypeofArrayIsArray","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Array","Type"],"shortDescription":"The typeof operator applied on an array returns 'array'"}},{"fields":{"slug":"/misconceptions/JavaScript/TypeofNullIsNull/","name":"TypeofNullIsNull","pl":"JavaScript","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["Value","Type"],"shortDescription":"The value null is of type 'null'"}},{"fields":{"slug":"/misconceptions/Python/AssignCompares/","name":"AssignCompares","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students may use (inadvertently or not) a single  =  operator in expressions used as conditions. Th…"}}},"frontmatter":{"status":"public","concepts":["Assignment","Equality","Expression","Operator"],"shortDescription":"= compares two values"}},{"fields":{"slug":"/misconceptions/Python/AssignmentCopiesObject/","name":"AssignmentCopiesObject","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students may be puzzled about the behavior of their programs when they use assignments involving mu…"}}},"frontmatter":{"status":"public","concepts":["Allocation","Assignment","Object","Reference","Value","Variable"],"shortDescription":"Assignment copies the object"}},{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeAccesses/","name":"CannotChainAttributeAccesses","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students only use atomic expressions on the left side of the dot in attribute accesses and method i…"}}},"frontmatter":{"status":"public","concepts":["Method","Call","Field","Member","Expression","Operator"],"shortDescription":"Attribute accesses cannot be chained together"}},{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeToObjectInstantiation/","name":"CannotChainAttributeToObjectInstantiation","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"shortDescription":"Method calls, and attribute accesses in general, cannot be chained to a constructor invocation."}},{"fields":{"slug":"/misconceptions/Python/ComparisonWithBoolLiteral/","name":"ComparisonWithBoolLiteral","pl":"Python","symptoms":{"childMdx":{"excerpt":"We observed two kinds of symptoms: specific patterns in code, and specific explanations. Code Patte…"}}},"frontmatter":{"status":"public","concepts":["Boolean","Equality","Evaluation","Expression","Literal","Operator"],"shortDescription":"To test whether an expression is True or False, one must compare it to True or to False"}},{"fields":{"slug":"/misconceptions/Python/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Python","symptoms":{"childMdx":{"excerpt":"This misconception can be detected by asking students to draw a control-flow graph of a sequence of…"}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-else is equivalent to sequence of two ifs"}},{"fields":{"slug":"/misconceptions/Python/DeferredReturn/","name":"DeferredReturn","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Return","ControlFlow","Function","Call"],"shortDescription":"A return statement in the middle of a function doesn't return immediately"}},{"fields":{"slug":"/misconceptions/Python/IfIsLoop/","name":"IfIsLoop","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students claim an  if -statement means \"ensure that this condition holds\" Students claim an  if -st…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Loop","ControlFlow"],"shortDescription":"The body of an if-statement executes repeatedly, as long as the condition holds"}},{"fields":{"slug":"/misconceptions/Python/InitCreates/","name":"InitCreates","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Allocation","Call","Constructor"],"shortDescription":"__init__ must create a new object"}},{"fields":{"slug":"/misconceptions/Python/InitReturnsObject/","name":"InitReturnsObject","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students might do the following: write an  __init__  method that returns  self write an  __init__  …"}}},"frontmatter":{"status":"public","concepts":["Allocation","Constructor","Call","Return"],"shortDescription":"__init__ needs to return an object"}},{"fields":{"slug":"/misconceptions/Python/MapToBooleanWithIf/","name":"MapToBooleanWithIf","pl":"Python","symptoms":{"childMdx":{"excerpt":"In the following examples, assume that  CONDITION  is a boolean expression (e.g,  is_happy() ,  i <…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Statement","Boolean","Evaluation"],"shortDescription":"To map a boolean expression to a bool, an if statement is necessary"}},{"fields":{"slug":"/misconceptions/Python/MapToBooleanWithTernaryOperator/","name":"MapToBooleanWithTernaryOperator","pl":"Python","symptoms":{"childMdx":{"excerpt":"In the following examples, assume that  CONDITION  is a boolean expression (e.g,  is_happy() ,  i <…"}}},"frontmatter":{"status":"public","concepts":["Conditional","Expression","Operator","Boolean"],"shortDescription":"To map a boolean expression to a bool, a ternary conditional operator is necessary"}},{"fields":{"slug":"/misconceptions/Python/MultipleValuesReturn/","name":"MultipleValuesReturn","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Value","Return","Function"],"shortDescription":"Functions can return multiple values"}},{"fields":{"slug":"/misconceptions/Python/NoAtomicExpression/","name":"NoAtomicExpression","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Operator","Literal","Variable"],"shortDescription":"Expressions must consist of more than one piece"}},{"fields":{"slug":"/misconceptions/Python/NoEmptyInit/","name":"NoEmptyInit","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Constructor"],"shortDescription":"__init__ must do something"}},{"fields":{"slug":"/misconceptions/Python/NoReservedWords/","name":"NoReservedWords","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Name"],"shortDescription":"Every sequence of letters and digits starting with a letter or an underscore can be used as an identifier"}},{"fields":{"slug":"/misconceptions/Python/NoSequenceRepetition/","name":"NoSequenceRepetition","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Sequence","Number","Repetition"],"shortDescription":"There is no operator that repeats sequences"}},{"fields":{"slug":"/misconceptions/Python/NoShortCircuit/","name":"NoShortCircuit","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"shortDescription":"and/or always evaluate both operands"}},{"fields":{"slug":"/misconceptions/Python/NoSingleLogicAnd/","name":"NoSingleLogicAnd","pl":"Python","symptoms":{"childMdx":{"excerpt":"If students claim that  &  is a bitwise AND, and  and  is a logical AND, then they probably also be…"}}},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator"],"shortDescription":"& is only a bitwise AND"}},{"fields":{"slug":"/misconceptions/Python/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students may: label an object in a diagram not just with the type, but also with a name (of some va…"}}},"frontmatter":{"status":"public","concepts":["Allocation","Call","Expression","Constructor","Name","Object"],"shortDescription":"A variable is needed to instantiate an object"}},{"fields":{"slug":"/misconceptions/Python/OutsideInFunctionNesting/","name":"OutsideInFunctionNesting","pl":"Python","symptoms":{"childMdx":{"excerpt":"This misconception occurred quite regularly, even for strong students. Here are two diagnostic prob…"}}},"frontmatter":{"status":"public","concepts":["Call","Composition","ControlFlow","Expression","Function"],"shortDescription":"Nested function calls are invoked outside in"}},{"fields":{"slug":"/misconceptions/Python/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument","pl":"Python","symptoms":{"childMdx":{"excerpt":"A student may write code as follows, assuming that  f  will be invoked"}}},"frontmatter":{"status":"public","concepts":["Function","Call","Expression"],"shortDescription":"() are optional for function calls without arguments"}},{"fields":{"slug":"/misconceptions/Python/PlusConcatenatesNumbers/","name":"PlusConcatenatesNumbers","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"draft","concepts":["String","Sequence","Number","Expression","Operator"],"shortDescription":"The plus operator can concatenate strings and numbers"}},{"fields":{"slug":"/misconceptions/Python/RecursiveFunctionNeedsIfElse/","name":"RecursiveFunctionNeedsIfElse","pl":"Python","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow","Recursion"],"shortDescription":"A recursive function needs to contain an if-else statement"}},{"fields":{"slug":"/misconceptions/Python/ReturnCall/","name":"ReturnCall","pl":"Python","symptoms":{"childMdx":{"excerpt":"The following example shows an occurrence of this misconception where only one of the three  return…"}}},"frontmatter":{"status":"public","concepts":["Call","Evaluation","Function","Return"],"shortDescription":"Return statements need () around the return value"}},{"fields":{"slug":"/misconceptions/Python/ReturnUnwindsMultipleFrames/","name":"ReturnUnwindsMultipleFrames","pl":"Python","symptoms":{"childMdx":{"excerpt":"A good way to detect this misconception is through the use of (UML-like) sequence diagrams. If the …"}}},"frontmatter":{"status":"public","concepts":["Call","Recursion","Return","Stack"],"shortDescription":"A return statement can unwind multiple call stack frames"}},{"fields":{"slug":"/misconceptions/Python/RightToLeftChaining/","name":"RightToLeftChaining","pl":"Python","symptoms":{"childMdx":{"excerpt":"This misconception can manifest itself when drawing expression trees, e.g., the tree for  a().b() ,…"}}},"frontmatter":{"status":"public","concepts":["Associativity","Call","ControlFlow","Evaluation","Expression","Field","Method"],"shortDescription":"Chained accesses are invoked from right to left"}},{"fields":{"slug":"/misconceptions/Python/SelfAssignable/","name":"SelfAssignable","pl":"Python","symptoms":{"childMdx":{"excerpt":"This misconception can manifest itself in code like the following: In this case, students may also …"}}},"frontmatter":{"status":"public","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"shortDescription":"Reassigning self changes the object on which a method is called"}},{"fields":{"slug":"/misconceptions/Python/SelfNoExpression/","name":"SelfNoExpression","pl":"Python","symptoms":{"childMdx":{"excerpt":"Students may believe that  self  on its own doesn't have any meaning. They might express statements…"}}},"frontmatter":{"status":"public","concepts":["Expression","Self"],"shortDescription":"The name self is not an expression"}},{"fields":{"slug":"/misconceptions/Python/StringLiteralNoObject/","name":"StringLiteralNoObject","pl":"Python","symptoms":{"childMdx":{"excerpt":"Novices may write code like this: possibly by analogy with: They may also never call methods on str…"}}},"frontmatter":{"status":"public","concepts":["Expression","Literal","Name","String"],"shortDescription":"One needs to call str to instantiate a str object from a string literal"}},{"fields":{"slug":"/misconceptions/Python/VariablesHoldExpressions/","name":"VariablesHoldExpressions","pl":"Python","symptoms":{"childMdx":{"excerpt":"A student holding this misconception may put the expression (not a reference to its value) into the…"}}},"frontmatter":{"status":"public","concepts":["Variable","Expression","Assignment","Value"],"shortDescription":"= stores an expression: it stores a reference to the expression in a variable"}},{"fields":{"slug":"/misconceptions/Python/VariablesHoldObjects/","name":"VariablesHoldObjects","pl":"Python","symptoms":{"childMdx":{"excerpt":"A common symptom of this misconception is the special case where students draw diagrams of memory\na…"}}},"frontmatter":{"status":"public","concepts":["Variable","Object","Reference","Value"],"shortDescription":"A variable contains a whole object"}},{"fields":{"slug":"/misconceptions/Scratch/BaseCaseNotNeeded/","name":"BaseCaseNotNeeded","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Recursion","Conditional","Call"],"shortDescription":"Recursive computations do not necessarily need a base case"}},{"fields":{"slug":"/misconceptions/Scratch/CompareBooleanToConstant/","name":"CompareBooleanToConstant","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Boolean","Expression","Operator","Equality"],"shortDescription":"To test whether an expression evaluates to true or false, one must compare it to a constant"}},{"fields":{"slug":"/misconceptions/Scratch/ConditionalIsSequence/","name":"ConditionalIsSequence","pl":"Scratch","symptoms":{"childMdx":{"excerpt":"This misconception can be detected by asking students to draw a control-flow graph."}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"If-then-else block is equivalent to sequence of two if-then blocks"}},{"fields":{"slug":"/misconceptions/Scratch/ElseAlwaysExecutes/","name":"ElseAlwaysExecutes","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"The else branch of an if-then-else block always executes"}},{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesListIdentities/","name":"EqualityOperatorComparesListIdentities","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Equality","Reference","Object","Value","Expression"],"shortDescription":"(list a) = (list b) compares the identities of list a and list b"}},{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesOnlyTypes/","name":"EqualityOperatorComparesOnlyTypes","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Operator","Equality","Type","Value"],"shortDescription":"() = () compares only the types of its operands"}},{"fields":{"slug":"/misconceptions/Scratch/ExpressionAssigns/","name":"ExpressionAssigns","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Expression","Assignment","Variable"],"shortDescription":"An expression that reads a variable also updates its value after the evaluation"}},{"fields":{"slug":"/misconceptions/Scratch/ListLengthCannotBeZero/","name":"ListLengthCannotBeZero","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Array"],"shortDescription":"A list cannot have a length of 0 items"}},{"fields":{"slug":"/misconceptions/Scratch/ListsHomogeneous/","name":"ListsHomogeneous","pl":"Scratch","symptoms":{"childMdx":{"excerpt":""}}},"frontmatter":{"status":"public","concepts":["Array","Type"],"shortDescription":"All items in a list must have the same type"}},{"fields":{"slug":"/misconceptions/Scratch/MissingElseTerminates/","name":"MissingElseTerminates","pl":"Scratch","symptoms":{"childMdx":{"excerpt":"Empirical Evidence This misconception appears in  Item P16  in the\n Scratch ProMAT  assessment: Que…"}}},"frontmatter":{"status":"public","concepts":["Conditional","ControlFlow"],"shortDescription":"Blocks following an if without else will not execute if the condition is false"}},{"fields":{"slug":"/misconceptions/Scratch/RepeatDistributes/","name":"RepeatDistributes","pl":"Scratch","symptoms":{"childMdx":{"excerpt":"Empirical Evidence This misconception appears in  Item P8  in the\n Scratch ProMAT  assessment: Ques…"}}},"frontmatter":{"status":"public","concepts":["Loop","ControlFlow"],"shortDescription":"Each block in a loop is repeated individually"}},{"fields":{"slug":"/misconceptions/Scratch/ResetStateEachLoopIteration/","name":"ResetStateEachLoopIteration","pl":"Scratch","symptoms":{"childMdx":{"excerpt":"Empirical Evidence Grover and Basu 's think aloud study\nand their  Item 8d  provide evidence of thi…"}}},"frontmatter":{"status":"public","concepts":["Loop","ControlFlow"],"shortDescription":"The computation of all loop iterations starts from the state before the loop"}},{"fields":{"slug":"/misconceptions/Scratch/ResetStateEachProgramExecution/","name":"ResetStateEachProgramExecution","pl":"Scratch","symptoms":{"childMdx":{"excerpt":"Empirical Evidence This misconception appears in  Item P9  in the\n Scratch ProMAT  assessment: Ques…"}}},"frontmatter":{"status":"public","concepts":["Variable","Lifetime"],"shortDescription":"Running a Scratch program first resets the state of the world and then executes the program"}}]}},"pageContext":{}},
    "staticQueryHashes": ["3649515864","4169798128"]}