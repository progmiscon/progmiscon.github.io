{
    "componentChunkName": "component---src-templates-notional-machine-js",
    "path": "/notionalMachines/StackHeapGlobalDiagram/",
    "result": {"data":{"nm":{"slug":"nms/StackHeapGlobalDiagram","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"type\": \"nm\",\n  \"id\": \"StackHeapGlobalDiagram\",\n  \"name\": \"Stack Heap Global Diagram\",\n  \"shortDescription\": \"Represent variables as boxes, organized in different memory areas\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This notional machine represents the state of a program\\nby showing three separate parts of memory:\\nthe stack with its stack frames and their local variables,\\nthe heap with heap objects and their instance variables,\\nand the global area with static variables.\"), mdx(\"p\", null, \"Every variable is shown as a rectangle\\ncontaining its current value.\\nVariables are annotated with their name.\\nIn statically typed languages,\\nvariables are also annotated with their type.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"id":"StackHeapGlobalDiagram","name":"Stack Heap Global Diagram","shortDescription":"Represent variables as boxes, organized in different memory areas","url":null}},"mcs":{"nodes":[{"fields":{"slug":"/misconceptions/Java/AddMemberAtRuntime/","name":"AddMemberAtRuntime"},"frontmatter":{"shortDescription":"Set of class members can change at runtime","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"before and after of object on heap"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayHasLengthMethod/","name":"ArrayHasLengthMethod"},"frontmatter":{"shortDescription":"To get the length of an array, one needs to call its length method","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array on heap with length field"},{"id":"ExpressionAsTree","how":"expression involving array length access"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayListIsArray/","name":"ArrayListIsArray"},"frontmatter":{"shortDescription":"ArrayLists are arrays","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"heap with array and ArrayList object"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayRankIsLength/","name":"ArrayRankIsLength"},"frontmatter":{"shortDescription":"Array rank and array length are the same thing","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays on heap"},{"id":"ExpressionAsTree","how":"expression involving array of arrays and array length"}]}},{"fields":{"slug":"/misconceptions/Java/ArraysGrow/","name":"ArraysGrow"},"frontmatter":{"shortDescription":"Arrays can grow dynamically","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array on heap with elements and length field"}]}},{"fields":{"slug":"/misconceptions/Java/AssignCompares/","name":"AssignCompares"},"frontmatter":{"shortDescription":"= compares two values","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"contents of variable before and after assignment"},{"id":"ExpressionAsTree","how":"expression involving assignment operator"}]}},{"fields":{"slug":"/misconceptions/Java/AssignmentCopiesObject/","name":"AssignmentCopiesObject"},"frontmatter":{"shortDescription":"Assignment copies the object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable and object on heap, before and after assignment"}]}},{"fields":{"slug":"/misconceptions/Java/CallWithoutFrame/","name":"CallWithoutFrame"},"frontmatter":{"shortDescription":"A method invocation does not necessarily allocate a stack frame","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack before and after call"}]}},{"fields":{"slug":"/misconceptions/Java/CallerFrameContainsCalleeFormal/","name":"CallerFrameContainsCalleeFormal"},"frontmatter":{"shortDescription":"Stack frame of caller includes variables for callee's formal parameters","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"caller and callee stack frames with variables and parameters"}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorAllocates/","name":"ConstructorAllocates"},"frontmatter":{"shortDescription":"The constructor allocates the object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"heap with object right before start of constructor"}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorParameterIsField/","name":"ConstructorParameterIsField"},"frontmatter":{"shortDescription":"Formal constructor parameters are equivalent to instance variables","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"constructor stack frame and object with instance variables"}]}},{"fields":{"slug":"/misconceptions/Java/EqualityOperatorComparesObjectsValues/","name":"EqualityOperatorComparesObjectsValues"},"frontmatter":{"shortDescription":"o==p compares the objects referred to by variables o and p","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"two reference variables and two heap objects"}]}},{"fields":{"slug":"/misconceptions/Java/EqualsComparesReferences/","name":"EqualsComparesReferences"},"frontmatter":{"shortDescription":"o.equals(p) compares the references stored in the variables o and p","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"two reference variables and two heap objects"}]}},{"fields":{"slug":"/misconceptions/Java/ExpressionAssigns/","name":"ExpressionAssigns"},"frontmatter":{"shortDescription":"An expression that reads a variable also updates its value after the evaluation","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable before and after access"},{"id":"ExpressionAsTree","how":"expression involving a variable access"}]}},{"fields":{"slug":"/misconceptions/Java/FinalReferenceImpliesImmutability/","name":"FinalReferenceImpliesImmutability"},"frontmatter":{"shortDescription":"An object referred to by a final variable is an immutable object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"final variable referring to heap object with instance variables"}]}},{"fields":{"slug":"/misconceptions/Java/ForEachVariableIsElement/","name":"ForEachVariableIsElement"},"frontmatter":{"shortDescription":"One can assign to the variable of an enhanced for statement to store a value in the corresponding array or collection element","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame with variable of enhanced for, heap with array or collection"}]}},{"fields":{"slug":"/misconceptions/Java/FrameIsClassInstance/","name":"FrameIsClassInstance"},"frontmatter":{"shortDescription":"A stack frame is the same as an instance of a class","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame and heap object"}]}},{"fields":{"slug":"/misconceptions/Java/ImmutableRequiresFinalParameters/","name":"ImmutableRequiresFinalParameters"},"frontmatter":{"shortDescription":"Immutable classes need final constructor/method parameters","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame with final parameters, heap object with final fields"}]}},{"fields":{"slug":"/misconceptions/Java/LocalVariablesAutoInitialized/","name":"LocalVariablesAutoInitialized"},"frontmatter":{"shortDescription":"Local variables are automatically initialized","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame with local variables"}]}},{"fields":{"slug":"/misconceptions/Java/MethodAsField/","name":"MethodAsField"},"frontmatter":{"shortDescription":"Each object contains its own special fields for all of its methods","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object with fields"}]}},{"fields":{"slug":"/misconceptions/Java/MultiReferenceVariable/","name":"MultiReferenceVariable"},"frontmatter":{"shortDescription":"A reference variable can point to multiple objects","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable referring to heap object"},{"id":"ExpressionAsTree","how":"value of expression involving reference variable access"}]}},{"fields":{"slug":"/misconceptions/Java/MultiValueVariable/","name":"MultiValueVariable"},"frontmatter":{"shortDescription":"A variable can contain more than one value","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable containing a value"},{"id":"ExpressionAsTree","how":"value of expression involving variable access"}]}},{"fields":{"slug":"/misconceptions/Java/MultidimensionalArray/","name":"MultidimensionalArray"},"frontmatter":{"shortDescription":"A multi-dimensional array is one single array object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays"},{"id":"ExpressionAsTree","how":"access of element of outer array nested array"}]}},{"fields":{"slug":"/misconceptions/Java/MustInitializeFieldInConstructor/","name":"MustInitializeFieldInConstructor"},"frontmatter":{"shortDescription":"Constructors must assign values to all fields","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"heap object before and after constructor"}]}},{"fields":{"slug":"/misconceptions/Java/NoFieldInheritance/","name":"NoFieldInheritance"},"frontmatter":{"shortDescription":"An object contains only the fields declared in its class","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object with fields"},{"id":"ExpressionAsTree","how":"expression involving instance variable access"}]}},{"fields":{"slug":"/misconceptions/Java/NoFieldlessObjects/","name":"NoFieldlessObjects"},"frontmatter":{"shortDescription":"Objects without instance variables can't exist","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object without instance variables"}]}},{"fields":{"slug":"/misconceptions/Java/NoJaggedArrays/","name":"NoJaggedArrays"},"frontmatter":{"shortDescription":"Multi-dimensional arrays have a rectangular shape","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays"},{"id":"ExpressionAsTree","how":"expression involving array length access of nested arrays"}]}},{"fields":{"slug":"/misconceptions/Java/NoLocalVariables/","name":"NoLocalVariables"},"frontmatter":{"shortDescription":"There are no local variables","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame with local variables"}]}},{"fields":{"slug":"/misconceptions/Java/NullIsObject/","name":"NullIsObject"},"frontmatter":{"shortDescription":"null is an object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable containing null"}]}},{"fields":{"slug":"/misconceptions/Java/NullPointerExceptionCompileTime/","name":"NullPointerExceptionCompileTime"},"frontmatter":{"shortDescription":"NullPointerExceptions are detected at compile time","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression with member access"},{"id":"StackHeapGlobalDiagram","how":"reference variable"}]}},{"fields":{"slug":"/misconceptions/Java/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed"},"frontmatter":{"shortDescription":"A variable is needed to instantiate an object","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving object allocation"},{"id":"StackHeapGlobalDiagram","how":"labeling a heap object with the name of some variable"}]}},{"fields":{"slug":"/misconceptions/Java/OnlyInnermostArrayElements/","name":"OnlyInnermostArrayElements"},"frontmatter":{"shortDescription":"Only the elements of the innermost array of a multi-dimensional array are accessible","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"nested array, variable directly referring to an inner array"},{"id":"ExpressionAsTree","how":"expression involving access of element of outer array of a nested array"}]}},{"fields":{"slug":"/misconceptions/Java/PrimitiveIsObject/","name":"PrimitiveIsObject"},"frontmatter":{"shortDescription":"Primitive values are heap objects","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable storing primitive value"}]}},{"fields":{"slug":"/misconceptions/Java/PrimitiveVariablesDynamicallyTyped/","name":"PrimitiveVariablesDynamicallyTyped"},"frontmatter":{"shortDescription":"The type of a primitive variable depends on its value","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"primitive variable before and after assignment"},{"id":"ExpressionAsTree","how":"typing of expression involving primitive variable access"}]}},{"fields":{"slug":"/misconceptions/Java/PrivateFieldsImplyImmutability/","name":"PrivateFieldsImplyImmutability"},"frontmatter":{"shortDescription":"A class where all fields are private is immutable","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object with fields"}]}},{"fields":{"slug":"/misconceptions/Java/PrivateFromOtherInstance/","name":"PrivateFromOtherInstance"},"frontmatter":{"shortDescription":"An object cannot access private members of other objects of the same class","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"two objects of the same class, instance method stack frame"}]}},{"fields":{"slug":"/misconceptions/Java/PrivateFromStatic/","name":"PrivateFromStatic"},"frontmatter":{"shortDescription":"Static methods cannot access private members of instances of same class","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object, static method stack frame"}]}},{"fields":{"slug":"/misconceptions/Java/PrivateMeansFinal/","name":"PrivateMeansFinal"},"frontmatter":{"shortDescription":"A private field cannot be changed","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object with fields"}]}},{"fields":{"slug":"/misconceptions/Java/RecursiveActivationsShareFrame/","name":"RecursiveActivationsShareFrame"},"frontmatter":{"shortDescription":"Recursive calls of a method share a stack frame","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"two stack frames of recursive method calls"}]}},{"fields":{"slug":"/misconceptions/Java/ReferenceIntoStack/","name":"ReferenceIntoStack"},"frontmatter":{"shortDescription":"References can point into the stack","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable containing a reference value"}]}},{"fields":{"slug":"/misconceptions/Java/ReferenceToVariable/","name":"ReferenceToVariable"},"frontmatter":{"shortDescription":"References can point to variables","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable containing a reference value"}]}},{"fields":{"slug":"/misconceptions/Java/StackTraceIsCallHistory/","name":"StackTraceIsCallHistory"},"frontmatter":{"shortDescription":"A stack trace is the sequence of previously called methods","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack with stack frames after a method returned"}]}},{"fields":{"slug":"/misconceptions/Java/StringLengthField/","name":"StringLengthField"},"frontmatter":{"shortDescription":"One can know the length of a String object by accessing its length field","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"String object"},{"id":"ExpressionAsTree","how":"expression involving method call or field access"}]}},{"fields":{"slug":"/misconceptions/Java/StringLiteralNoObject/","name":"StringLiteralNoObject"},"frontmatter":{"shortDescription":"One needs to call the String constructor to get a String object from a literal","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"String object, stack frame of String constructor with String argument"},{"id":"ExpressionAsTree","how":"expression involving String literal"}]}},{"fields":{"slug":"/misconceptions/Java/SubtypeCompatibleWithSupertype/","name":"SubtypeCompatibleWithSupertype"},"frontmatter":{"shortDescription":"A variable of a subtype can reference an object of a supertype","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable with given type referring to object of a supertype"}]}},{"fields":{"slug":"/misconceptions/Java/SuperclassObjectAllocated/","name":"SuperclassObjectAllocated"},"frontmatter":{"shortDescription":"When instantiating an object of a subclass, an object of a superclass is also allocated","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"heap after allocating an object of a class that has a superclass"}]}},{"fields":{"slug":"/misconceptions/Java/SupertypeIncompatibleWithSubtype/","name":"SupertypeIncompatibleWithSubtype"},"frontmatter":{"shortDescription":"A variable of a supertype cannot reference an object of a subtype","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable of a given type referring to object of a subtype"}]}},{"fields":{"slug":"/misconceptions/Java/ThisAsField/","name":"ThisAsField"},"frontmatter":{"shortDescription":"this is a special field in the object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object containing variables, stack frame containing variables"}]}},{"fields":{"slug":"/misconceptions/Java/ThisAssignable/","name":"ThisAssignable"},"frontmatter":{"shortDescription":"One can assign to this","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing this"},{"id":"ExpressionAsTree","how":"expression involving assignment"}]}},{"fields":{"slug":"/misconceptions/Java/ThisCanBeNull/","name":"ThisCanBeNull"},"frontmatter":{"shortDescription":"this can be null","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing this"},{"id":"ExpressionAsTree","how":"evaluation of expression involving this"}]}},{"fields":{"slug":"/misconceptions/Java/ThisExistsInStaticMethod/","name":"ThisExistsInStaticMethod"},"frontmatter":{"shortDescription":"this is a local variable, also in static methods","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame of a static method"}]}},{"fields":{"slug":"/misconceptions/Java/ThisInConstructorIsNull/","name":"ThisInConstructorIsNull"},"frontmatter":{"shortDescription":"In a constructor, this is null","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame of a constructor with this"},{"id":"ExpressionAsTree","how":"expression involving this"}]}},{"fields":{"slug":"/misconceptions/Java/UntypedVariables/","name":"UntypedVariables"},"frontmatter":{"shortDescription":"Variable declarations don't need a type","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable with type"}]}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldExpressions/","name":"VariablesHoldExpressions"},"frontmatter":{"shortDescription":"= stores an expression in a variable","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable containing a value"},{"id":"ExpressionAsTree","how":"evaluation of expression with assignment where r-value is not a literal"}]}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldObjects/","name":"VariablesHoldObjects"},"frontmatter":{"shortDescription":"A variable of a reference type contains a whole object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object on the heap, variable of reference type containing a value"}]}},{"fields":{"slug":"/misconceptions/Python/AssignCompares/","name":"AssignCompares"},"frontmatter":{"shortDescription":"= compares two values","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"contents of variable before and after assignment"}]}},{"fields":{"slug":"/misconceptions/Python/InitCreates/","name":"InitCreates"},"frontmatter":{"shortDescription":"__init__ must create a new object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"heap with object right before start of constructor"}]}},{"fields":{"slug":"/misconceptions/Python/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed"},"frontmatter":{"shortDescription":"A variable is needed to instantiate an object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"labeling a heap object with the name of some variable"}]}},{"fields":{"slug":"/misconceptions/Python/SelfAssignable/","name":"SelfAssignable"},"frontmatter":{"shortDescription":"Reassigning self changes the object on which a method is called","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing self"},{"id":"ExpressionAsTree","how":"expression involving assignment"}]}},{"fields":{"slug":"/misconceptions/Python/StringLiteralNoObject/","name":"StringLiteralNoObject"},"frontmatter":{"shortDescription":"One needs to call str to instantiate a str object from a string literal","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"str object, stack frame of str constructor with str argument"},{"id":"ExpressionAsTree","how":"expression involving str literal"}]}},{"fields":{"slug":"/misconceptions/Scratch/EqualityOperatorComparesListIdentities/","name":"EqualityOperatorComparesListIdentities"},"frontmatter":{"shortDescription":"(list a) = (list b) compares the identities of list a and list b","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"names referring to list \"objects\""}]}}]}},"pageContext":{"name":"StackHeapGlobalDiagram","slug":"nms/StackHeapGlobalDiagram"}},
    "staticQueryHashes": ["3281885743","3649515864","4169798128"]}