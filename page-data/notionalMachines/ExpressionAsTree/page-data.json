{
    "componentChunkName": "component---src-templates-notional-machine-js",
    "path": "/notionalMachines/ExpressionAsTree/",
    "result": {"data":{"nm":{"slug":"nms/ExpressionAsTree","body":"var _excluded = [\"components\"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"type\": \"nm\",\n  \"id\": \"ExpressionAsTree\",\n  \"name\": \"Expression as Tree\",\n  \"shortDescription\": \"Represent operators and operands as tree nodes\"\n};\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\nvar ExpressionTreeViewer = makeShortcode(\"ExpressionTreeViewer\");\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This notional machine represents a source code expression\\nin the form of a tree.\\nThis makes the structure of the expression explicit,\\nand it allows visualizing the various steps of expression evaluation.\\nIt also allows annotating the various subexpressions with their types.\"), mdx(\"p\", null, \"An expression tree is essentially an abstract syntax tree (AST),\\nfocused on just an expression.\"), mdx(\"p\", null, \"Here is an example Java expression:\"), mdx(\"div\", {\n    \"className\": \"gatsby-highlight\",\n    \"data-language\": \"java\"\n  }, mdx(\"pre\", {\n    parentName: \"div\",\n    \"className\": \"language-java\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"1\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"2\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token string\"\n  }, \"\\\"AAA\\\"\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"3\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token operator\"\n  }, \"+\"), \" \", mdx(\"span\", {\n    parentName: \"code\",\n    \"className\": \"token number\"\n  }, \"4\")))), mdx(\"p\", null, \"The corresponding \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"expression tree\"), \"\\nshows not only the expression\\u2019s structure\\nbut also the types and values of all subexpressions:\"), mdx(ExpressionTreeViewer, {\n    height: 550,\n    nodes: [{\n      \"id\": 1,\n      \"pieces\": [\"1\"],\n      \"x\": 42.5,\n      \"y\": 437,\n      \"width\": 38.40234375,\n      \"type\": \"int\",\n      \"value\": \"1\",\n      \"isFinal\": false\n    }, {\n      \"id\": 2,\n      \"pieces\": [\"2\"],\n      \"x\": 162.5,\n      \"y\": 440,\n      \"width\": 38.40234375,\n      \"type\": \"int\",\n      \"value\": \"2\",\n      \"isFinal\": false\n    }, {\n      \"id\": 3,\n      \"pieces\": [\"{{}}\", \" + \", \"{{}}\"],\n      \"x\": 80.5,\n      \"y\": 352,\n      \"width\": 105.61171875,\n      \"type\": \"int\",\n      \"value\": \"3\",\n      \"isFinal\": false\n    }, {\n      \"id\": 4,\n      \"pieces\": [\"{{}}\", \" + \", \"{{}}\"],\n      \"x\": 177.5,\n      \"y\": 271,\n      \"width\": 105.61171875,\n      \"type\": \"String\",\n      \"value\": \"\\\"3AAA\\\"\",\n      \"isFinal\": false\n    }, {\n      \"id\": 5,\n      \"pieces\": [\"\\\"AAA\\\"\"],\n      \"x\": 288.5,\n      \"y\": 353,\n      \"width\": 67.20703125,\n      \"type\": \"String\",\n      \"value\": \"\\\"AAA\\\"\",\n      \"isFinal\": false\n    }, {\n      \"id\": 6,\n      \"pieces\": [\"3\"],\n      \"x\": 389.5,\n      \"y\": 271,\n      \"width\": 38.40234375,\n      \"type\": \"int\",\n      \"value\": \"3\",\n      \"isFinal\": false\n    }, {\n      \"id\": 7,\n      \"pieces\": [\"{{}}\", \" + \", \"{{}}\"],\n      \"x\": 262.5,\n      \"y\": 176,\n      \"width\": 105.61171875,\n      \"type\": \"String\",\n      \"value\": \"\\\"3AAA3\\\"\",\n      \"isFinal\": false\n    }, {\n      \"id\": 8,\n      \"pieces\": [\"{{}}\", \" + \", \"{{}}\"],\n      \"x\": 363.5,\n      \"y\": 70,\n      \"width\": 105.61171875,\n      \"type\": \"String\",\n      \"value\": \"\\\"3AAA34\\\"\",\n      \"isFinal\": false\n    }, {\n      \"id\": 9,\n      \"pieces\": [\"4\"],\n      \"x\": 474.5,\n      \"y\": 176,\n      \"width\": 38.40234375,\n      \"type\": \"int\",\n      \"value\": \"4\",\n      \"isFinal\": false\n    }],\n    edges: [{\n      \"childNodeId\": 1,\n      \"parentNodeId\": 3,\n      \"parentPieceId\": 0,\n      \"id\": 1\n    }, {\n      \"childNodeId\": 2,\n      \"parentNodeId\": 3,\n      \"parentPieceId\": 2,\n      \"id\": 2\n    }, {\n      \"childNodeId\": 3,\n      \"parentNodeId\": 4,\n      \"parentPieceId\": 0,\n      \"id\": 3\n    }, {\n      \"childNodeId\": 5,\n      \"parentNodeId\": 4,\n      \"parentPieceId\": 2,\n      \"id\": 4\n    }, {\n      \"childNodeId\": 4,\n      \"parentNodeId\": 7,\n      \"parentPieceId\": 0,\n      \"id\": 5\n    }, {\n      \"childNodeId\": 6,\n      \"parentNodeId\": 7,\n      \"parentPieceId\": 2,\n      \"id\": 6\n    }, {\n      \"childNodeId\": 7,\n      \"parentNodeId\": 8,\n      \"parentPieceId\": 0,\n      \"id\": 7\n    }, {\n      \"childNodeId\": 9,\n      \"parentNodeId\": 8,\n      \"parentPieceId\": 2,\n      \"id\": 8\n    }],\n    mdxType: \"ExpressionTreeViewer\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"id":"ExpressionAsTree","name":"Expression as Tree","shortDescription":"Represent operators and operands as tree nodes","url":null}},"mcs":{"nodes":[{"fields":{"slug":"/misconceptions/Java/ArithmeticPlusPrecedes/","name":"ArithmeticPlusPrecedes"},"frontmatter":{"shortDescription":"Addition has higher precedence than string concatenation","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression using both operators"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayAccessWithParentheses/","name":"ArrayAccessWithParentheses"},"frontmatter":{"shortDescription":"Parentheses are used to access an element in an array","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving array access"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayAllocationWithoutNew/","name":"ArrayAllocationWithoutNew"},"frontmatter":{"shortDescription":"Arrays are created without the new keyword","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving array allocation"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayBracketCountIsLength/","name":"ArrayBracketCountIsLength"},"frontmatter":{"shortDescription":"The number of brackets in an array type or an array initializer corresponds to the length of the array","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression using array allocation and access"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayElementTypeRepeats/","name":"ArrayElementTypeRepeats"},"frontmatter":{"shortDescription":"The type of a multi-dimensional array is written as T[] T[] T[]","expressibleInNms":[{"id":"ExpressionAsTree","how":"type of expression involving multi-dimensional array"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayHasLengthMethod/","name":"ArrayHasLengthMethod"},"frontmatter":{"shortDescription":"To get the length of an array, one needs to call its length method","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array on heap with length field"},{"id":"ExpressionAsTree","how":"expression involving array length access"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayInitializerContentsInBrackets/","name":"ArrayInitializerContentsInBrackets"},"frontmatter":{"shortDescription":"Array initializers list the elements in square brackets","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving array initializer"}]}},{"fields":{"slug":"/misconceptions/Java/ArrayRankIsLength/","name":"ArrayRankIsLength"},"frontmatter":{"shortDescription":"Array rank and array length are the same thing","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays on heap"},{"id":"ExpressionAsTree","how":"expression involving array of arrays and array length"}]}},{"fields":{"slug":"/misconceptions/Java/AssignCompares/","name":"AssignCompares"},"frontmatter":{"shortDescription":"= compares two values","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"contents of variable before and after assignment"},{"id":"ExpressionAsTree","how":"expression involving assignment operator"}]}},{"fields":{"slug":"/misconceptions/Java/AssignmentNotExpression/","name":"AssignmentNotExpression"},"frontmatter":{"shortDescription":"An assignment a=b is not an expression","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving assignment"}]}},{"fields":{"slug":"/misconceptions/Java/CallOnPrimitive/","name":"CallOnPrimitive"},"frontmatter":{"shortDescription":"One can invoke a method on primitive values","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving method call"}]}},{"fields":{"slug":"/misconceptions/Java/CallRequiresVariable/","name":"CallRequiresVariable"},"frontmatter":{"shortDescription":"One needs a variable to invoke a method","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving a method call"}]}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberAccesses/","name":"CannotChainMemberAccesses"},"frontmatter":{"shortDescription":"Member accesses cannot be chained together","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving chained member accesses"}]}},{"fields":{"slug":"/misconceptions/Java/CannotChainMemberToConstructor/","name":"CannotChainMemberToConstructor"},"frontmatter":{"shortDescription":"Method calls or field accesses cannot be chained to a constructor invocation","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving member access chained to constructor call"}]}},{"fields":{"slug":"/misconceptions/Java/ChainedMethodsNotCalledFromOutside/","name":"ChainedMethodsNotCalledFromOutside"},"frontmatter":{"shortDescription":"Chained methods are all called on the object at the beginning of the chain","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving chained method calls"}]}},{"fields":{"slug":"/misconceptions/Java/CharNotNumeric/","name":"CharNotNumeric"},"frontmatter":{"shortDescription":"Char is not a numeric type","expressibleInNms":[{"id":"ExpressionAsTree","how":"numerical operation with char operand"}]}},{"fields":{"slug":"/misconceptions/Java/ComparisonWithBooleanLiteral/","name":"ComparisonWithBooleanLiteral"},"frontmatter":{"shortDescription":"To test whether an expression is true or false, one must compare it to true or to false","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving comparison of boolean subexpression to boolean literal"}]}},{"fields":{"slug":"/misconceptions/Java/CompositeExpressionsUntyped/","name":"CompositeExpressionsUntyped"},"frontmatter":{"shortDescription":"Expressions that consist of multiple parts have no type","expressibleInNms":[{"id":"ExpressionAsTree","how":"typing of composite expression"}]}},{"fields":{"slug":"/misconceptions/Java/ConstructorWithoutNew/","name":"ConstructorWithoutNew"},"frontmatter":{"shortDescription":"One can write the constructor name, without new, to instantiate a class","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving object allocation"}]}},{"fields":{"slug":"/misconceptions/Java/EvaluationResultsArePrinted/","name":"EvaluationResultsArePrinted"},"frontmatter":{"shortDescription":"Evaluating an expression means outputting its result","expressibleInNms":[{"id":"ExpressionAsTree","how":"any expression"}]}},{"fields":{"slug":"/misconceptions/Java/ExpressionAssigns/","name":"ExpressionAssigns"},"frontmatter":{"shortDescription":"An expression that reads a variable also updates its value after the evaluation","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable before and after access"},{"id":"ExpressionAsTree","how":"expression involving a variable access"}]}},{"fields":{"slug":"/misconceptions/Java/ExpressionsDynamicallyTyped/","name":"ExpressionsDynamicallyTyped"},"frontmatter":{"shortDescription":"One has to evaluate an expression to determine its type","expressibleInNms":[{"id":"ExpressionAsTree","how":"any expression"}]}},{"fields":{"slug":"/misconceptions/Java/IntegerDivisionToRational/","name":"IntegerDivisionToRational"},"frontmatter":{"shortDescription":"Dividing two integers can produce a rational number","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving division of two integers"}]}},{"fields":{"slug":"/misconceptions/Java/LiteralNoExpression/","name":"LiteralNoExpression"},"frontmatter":{"shortDescription":"A literal is not an expression","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression consisting of just a literal"}]}},{"fields":{"slug":"/misconceptions/Java/LiteralString/","name":"LiteralString"},"frontmatter":{"shortDescription":"When passing a literal string as argument to a method, no quotes are needed","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving a method call with a string literal as argument"}]}},{"fields":{"slug":"/misconceptions/Java/MapToBooleanWithConditionalOperator/","name":"MapToBooleanWithConditionalOperator"},"frontmatter":{"shortDescription":"To map a boolean expression to a boolean, a conditional operator is necessary","expressibleInNms":[{"id":"ExpressionAsTree","how":"boolean expression"}]}},{"fields":{"slug":"/misconceptions/Java/MultiReferenceVariable/","name":"MultiReferenceVariable"},"frontmatter":{"shortDescription":"A reference variable can point to multiple objects","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"reference variable referring to heap object"},{"id":"ExpressionAsTree","how":"value of expression involving reference variable access"}]}},{"fields":{"slug":"/misconceptions/Java/MultiValueVariable/","name":"MultiValueVariable"},"frontmatter":{"shortDescription":"A variable can contain more than one value","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable containing a value"},{"id":"ExpressionAsTree","how":"value of expression involving variable access"}]}},{"fields":{"slug":"/misconceptions/Java/MultidimensionalArray/","name":"MultidimensionalArray"},"frontmatter":{"shortDescription":"A multi-dimensional array is one single array object","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays"},{"id":"ExpressionAsTree","how":"access of element of outer array nested array"}]}},{"fields":{"slug":"/misconceptions/Java/NoAtomicExpression/","name":"NoAtomicExpression"},"frontmatter":{"shortDescription":"Expressions must consist of more than one piece","expressibleInNms":[{"id":"ExpressionAsTree","how":"atomic expression"}]}},{"fields":{"slug":"/misconceptions/Java/NoCallOnStringLiteral/","name":"NoCallOnStringLiteral"},"frontmatter":{"shortDescription":"One cannot invoke methods on String literals","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving method call on string literal"}]}},{"fields":{"slug":"/misconceptions/Java/NoCastIfSameSize/","name":"NoCastIfSameSize"},"frontmatter":{"shortDescription":"If a variable is at least as big (bit-width) as a value, then no cast is needed to a assign the value to the variable","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving assignment of smaller bit-width value to larger bit-width variable"}]}},{"fields":{"slug":"/misconceptions/Java/NoFieldInheritance/","name":"NoFieldInheritance"},"frontmatter":{"shortDescription":"An object contains only the fields declared in its class","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"object with fields"},{"id":"ExpressionAsTree","how":"expression involving instance variable access"}]}},{"fields":{"slug":"/misconceptions/Java/NoFloatLiterals/","name":"NoFloatLiterals"},"frontmatter":{"shortDescription":"There are no float literals","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving float literal"}]}},{"fields":{"slug":"/misconceptions/Java/NoImplicitWidening/","name":"NoImplicitWidening"},"frontmatter":{"shortDescription":"Smaller types are never automatically converted into bigger ones without an explicit cast","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving assignment of value of smaller type to variable of bigger type"}]}},{"fields":{"slug":"/misconceptions/Java/NoJaggedArrays/","name":"NoJaggedArrays"},"frontmatter":{"shortDescription":"Multi-dimensional arrays have a rectangular shape","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"array of arrays"},{"id":"ExpressionAsTree","how":"expression involving array length access of nested arrays"}]}},{"fields":{"slug":"/misconceptions/Java/NoLongLiterals/","name":"NoLongLiterals"},"frontmatter":{"shortDescription":"There are no long literals","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving long literal"}]}},{"fields":{"slug":"/misconceptions/Java/NoMethodInheritance/","name":"NoMethodInheritance"},"frontmatter":{"shortDescription":"Subclasses inherit fields but not methods","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving call of inherited method"}]}},{"fields":{"slug":"/misconceptions/Java/NoShortCircuit/","name":"NoShortCircuit"},"frontmatter":{"shortDescription":"&& and || always evaluate both operands","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving short-circuit operator"},{"id":"ControlFlowAsGraph","how":"graph of conditional involving short-circuit operator"}]}},{"fields":{"slug":"/misconceptions/Java/NoSingleLogicAnd/","name":"NoSingleLogicAnd"},"frontmatter":{"shortDescription":"& is only a bitwise AND","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving & on integers"}]}},{"fields":{"slug":"/misconceptions/Java/NoStringToString/","name":"NoStringToString"},"frontmatter":{"shortDescription":"One cannot invoke toString() on a String","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving call of toString() on a string"}]}},{"fields":{"slug":"/misconceptions/Java/NullPointerExceptionCompileTime/","name":"NullPointerExceptionCompileTime"},"frontmatter":{"shortDescription":"NullPointerExceptions are detected at compile time","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression with member access"},{"id":"StackHeapGlobalDiagram","how":"reference variable"}]}},{"fields":{"slug":"/misconceptions/Java/NumericToBooleanCoercion/","name":"NumericToBooleanCoercion"},"frontmatter":{"shortDescription":"Numeric types can be coerced to boolean","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving numeric subexpression"}]}},{"fields":{"slug":"/misconceptions/Java/ObjectsMustBeNamed/","name":"ObjectsMustBeNamed"},"frontmatter":{"shortDescription":"A variable is needed to instantiate an object","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving object allocation"},{"id":"StackHeapGlobalDiagram","how":"labeling a heap object with the name of some variable"}]}},{"fields":{"slug":"/misconceptions/Java/OnlyInnermostArrayElements/","name":"OnlyInnermostArrayElements"},"frontmatter":{"shortDescription":"Only the elements of the innermost array of a multi-dimensional array are accessible","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"nested array, variable directly referring to an inner array"},{"id":"ExpressionAsTree","how":"expression involving access of element of outer array of a nested array"}]}},{"fields":{"slug":"/misconceptions/Java/OutOfBoundsElementsAreNull/","name":"OutOfBoundsElementsAreNull"},"frontmatter":{"shortDescription":"Out-of-bounds array elements are null","expressibleInNms":[{"id":"ExpressionAsTree","how":"evaluation of expression accessing out-of-bounds array element"}]}},{"fields":{"slug":"/misconceptions/Java/OutsideInMethodNesting/","name":"OutsideInMethodNesting"},"frontmatter":{"shortDescription":"Nested method calls are invoked outside in","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving nested method calls"}]}},{"fields":{"slug":"/misconceptions/Java/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument"},"frontmatter":{"shortDescription":"() are optional for method calls without arguments","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving call of method without arguments"}]}},{"fields":{"slug":"/misconceptions/Java/PrimitiveVariablesDynamicallyTyped/","name":"PrimitiveVariablesDynamicallyTyped"},"frontmatter":{"shortDescription":"The type of a primitive variable depends on its value","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"primitive variable before and after assignment"},{"id":"ExpressionAsTree","how":"typing of expression involving primitive variable access"}]}},{"fields":{"slug":"/misconceptions/Java/PrivateAccessibleInSubclass/","name":"PrivateAccessibleInSubclass"},"frontmatter":{"shortDescription":"Private members of a superclass are accessible from a subclass","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving superclass member access"}]}},{"fields":{"slug":"/misconceptions/Java/RationalLiterals/","name":"RationalLiterals"},"frontmatter":{"shortDescription":"Rational fractions are literals","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving division of two integer literals"}]}},{"fields":{"slug":"/misconceptions/Java/ReferenceToBooleanCoercion/","name":"ReferenceToBooleanCoercion"},"frontmatter":{"shortDescription":"Every reference type can be coerced to boolean","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving subexpression of reference type"}]}},{"fields":{"slug":"/misconceptions/Java/ReferenceToIntegerConversion/","name":"ReferenceToIntegerConversion"},"frontmatter":{"shortDescription":"One can cast between references and ints","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving subexpression of reference type"}]}},{"fields":{"slug":"/misconceptions/Java/RightToLeftChaining/","name":"RightToLeftChaining"},"frontmatter":{"shortDescription":"Chained accesses are invoked from right to left","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving chained member accesses"}]}},{"fields":{"slug":"/misconceptions/Java/SingleQuoteString/","name":"SingleQuoteString"},"frontmatter":{"shortDescription":"String literals can be in single quotes","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving String literal"}]}},{"fields":{"slug":"/misconceptions/Java/StringLengthField/","name":"StringLengthField"},"frontmatter":{"shortDescription":"One can know the length of a String object by accessing its length field","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"String object"},{"id":"ExpressionAsTree","how":"expression involving method call or field access"}]}},{"fields":{"slug":"/misconceptions/Java/StringLiteralNoObject/","name":"StringLiteralNoObject"},"frontmatter":{"shortDescription":"One needs to call the String constructor to get a String object from a literal","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"String object, stack frame of String constructor with String argument"},{"id":"ExpressionAsTree","how":"expression involving String literal"}]}},{"fields":{"slug":"/misconceptions/Java/StringPlusStringifiesExpression/","name":"StringPlusStringifiesExpression"},"frontmatter":{"shortDescription":"String concatenation stringifies non-String operand expressions","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving concatenation of String and non-String"}]}},{"fields":{"slug":"/misconceptions/Java/StringRepetitionOperator/","name":"StringRepetitionOperator"},"frontmatter":{"shortDescription":"The multiplication operator can repeat a String a number of times","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving String and integer"}]}},{"fields":{"slug":"/misconceptions/Java/SuperAlwaysHasParentheses/","name":"SuperAlwaysHasParentheses"},"frontmatter":{"shortDescription":"To call a method on a superclass, parentheses are needed after the keyword super","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving a super method call"}]}},{"fields":{"slug":"/misconceptions/Java/TargetTyping/","name":"TargetTyping"},"frontmatter":{"shortDescription":"The type of a numerical expression depends on the type expected by the surrounding context","expressibleInNms":[{"id":"ExpressionAsTree","how":"typing of numerical expression"}]}},{"fields":{"slug":"/misconceptions/Java/ThisAssignable/","name":"ThisAssignable"},"frontmatter":{"shortDescription":"One can assign to this","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing this"},{"id":"ExpressionAsTree","how":"expression involving assignment"}]}},{"fields":{"slug":"/misconceptions/Java/ThisCanBeNull/","name":"ThisCanBeNull"},"frontmatter":{"shortDescription":"this can be null","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing this"},{"id":"ExpressionAsTree","how":"evaluation of expression involving this"}]}},{"fields":{"slug":"/misconceptions/Java/ThisInConstructorIsNull/","name":"ThisInConstructorIsNull"},"frontmatter":{"shortDescription":"In a constructor, this is null","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame of a constructor with this"},{"id":"ExpressionAsTree","how":"expression involving this"}]}},{"fields":{"slug":"/misconceptions/Java/ThisNoExpression/","name":"ThisNoExpression"},"frontmatter":{"shortDescription":"The name this is not an expression","expressibleInNms":[{"id":"ExpressionAsTree","how":"atomic expression this"}]}},{"fields":{"slug":"/misconceptions/Java/ToStringPrints/","name":"ToStringPrints"},"frontmatter":{"shortDescription":"Invoking toString() prints something","expressibleInNms":[{"id":"ExpressionAsTree","how":"evaluation of expression involving toString() call"}]}},{"fields":{"slug":"/misconceptions/Java/VariablesHoldExpressions/","name":"VariablesHoldExpressions"},"frontmatter":{"shortDescription":"= stores an expression in a variable","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"variable containing a value"},{"id":"ExpressionAsTree","how":"evaluation of expression with assignment where r-value is not a literal"}]}},{"fields":{"slug":"/misconceptions/Python/CannotChainAttributeAccesses/","name":"CannotChainAttributeAccesses"},"frontmatter":{"shortDescription":"Attribute accesses cannot be chained together","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving chained member accesses"}]}},{"fields":{"slug":"/misconceptions/Python/ComparisonWithBoolLiteral/","name":"ComparisonWithBoolLiteral"},"frontmatter":{"shortDescription":"To test whether an expression is True or False, one must compare it to True or to False","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving comparison of boolean subexpression to boolean literal"}]}},{"fields":{"slug":"/misconceptions/Python/MapToBooleanWithTernaryOperator/","name":"MapToBooleanWithTernaryOperator"},"frontmatter":{"shortDescription":"To map a boolean expression to a bool, a ternary conditional operator is necessary","expressibleInNms":[{"id":"ExpressionAsTree","how":"boolean expression"}]}},{"fields":{"slug":"/misconceptions/Python/NoShortCircuit/","name":"NoShortCircuit"},"frontmatter":{"shortDescription":"and/or always evaluate both operands","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving short-circuit operator"},{"id":"ControlFlowAsGraph","how":"graph of conditional involving short-circuit operator"}]}},{"fields":{"slug":"/misconceptions/Python/NoSingleLogicAnd/","name":"NoSingleLogicAnd"},"frontmatter":{"shortDescription":"& is only a bitwise AND","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving & on booleans"}]}},{"fields":{"slug":"/misconceptions/Python/OutsideInFunctionNesting/","name":"OutsideInFunctionNesting"},"frontmatter":{"shortDescription":"Nested function calls are invoked outside in","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving nested method calls"}]}},{"fields":{"slug":"/misconceptions/Python/ParenthesesOnlyIfArgument/","name":"ParenthesesOnlyIfArgument"},"frontmatter":{"shortDescription":"() are optional for function calls without arguments","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving call of function without arguments"}]}},{"fields":{"slug":"/misconceptions/Python/SelfAssignable/","name":"SelfAssignable"},"frontmatter":{"shortDescription":"Reassigning self changes the object on which a method is called","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"stack frame containing self"},{"id":"ExpressionAsTree","how":"expression involving assignment"}]}},{"fields":{"slug":"/misconceptions/Python/SelfNoExpression/","name":"SelfNoExpression"},"frontmatter":{"shortDescription":"The name self is not an expression","expressibleInNms":[{"id":"ExpressionAsTree","how":"atomic expression self"}]}},{"fields":{"slug":"/misconceptions/Python/StringLiteralNoObject/","name":"StringLiteralNoObject"},"frontmatter":{"shortDescription":"One needs to call str to instantiate a str object from a string literal","expressibleInNms":[{"id":"StackHeapGlobalDiagram","how":"str object, stack frame of str constructor with str argument"},{"id":"ExpressionAsTree","how":"expression involving str literal"}]}},{"fields":{"slug":"/misconceptions/Scratch/CompareBooleanToConstant/","name":"CompareBooleanToConstant"},"frontmatter":{"shortDescription":"To test whether an expression evaluates to true or false, one must compare it to a constant","expressibleInNms":[{"id":"ExpressionAsTree","how":"expression involving comparison of boolean subexpression to boolean literal"}]}}]}},"pageContext":{"name":"ExpressionAsTree","slug":"nms/ExpressionAsTree"}},
    "staticQueryHashes": ["3281885743","3649515864","4169798128"]}