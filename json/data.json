{"meta":{"source":"https://progmiscon.org","publicationDate":"2025-09-25T14:07:01.188Z"},"pls":["Java","JavaScript","Python","Scratch"],"concepts":[{"name":"Abstraction"},{"name":"AccessModifier"},{"name":"Allocation"},{"name":"Argument"},{"name":"Array"},{"name":"Assignment"},{"name":"Associativity"},{"name":"Boolean"},{"name":"Call"},{"name":"Class"},{"name":"Composition"},{"name":"Conditional"},{"name":"Constructor"},{"name":"ControlFlow"},{"name":"Equality"},{"name":"Evaluation"},{"name":"Exception"},{"name":"Expression"},{"name":"Field"},{"name":"Function"},{"name":"GarbageCollection"},{"name":"Implementation"},{"name":"Inheritance"},{"name":"Input"},{"name":"Lifetime"},{"name":"Literal"},{"name":"Loop"},{"name":"Member"},{"name":"Method"},{"name":"Mutability"},{"name":"Name"},{"name":"Null"},{"name":"Number"},{"name":"Object"},{"name":"Operator"},{"name":"Output"},{"name":"Parameter"},{"name":"Polymorphism"},{"name":"Precedence"},{"name":"Primitive"},{"name":"Prototype"},{"name":"Recursion"},{"name":"Reference"},{"name":"Repetition"},{"name":"Return"},{"name":"Scope"},{"name":"Self"},{"name":"Sequence"},{"name":"Stack"},{"name":"Statement"},{"name":"Static"},{"name":"String"},{"name":"Subtyping"},{"name":"Term"},{"name":"Type"},{"name":"Undefined"},{"name":"Value"},{"name":"Variable"}],"misconceptions":[{"name":"AbstractClassMustImplementAbstractMethod","pl":"Java","shortDescription":"An abstract class must implement all abstract methods defined in its superclass","shortCorrection":"An abstract class does not need to implement all abstract methods defined in its superclass","concepts":["Class","Inheritance","Implementation"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.1.1","8.4.3.1","8.4.8"]}]},{"name":"AbstractClassNoImplementation","pl":"Java","shortDescription":"An abstract class cannot contain implemented methods","shortCorrection":"An abstract class can also contain implemented methods","concepts":["Class","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.1.1","8.4.3.1"]}]},{"name":"AddMemberAtRuntime","pl":"Java","shortDescription":"Set of class members can change at runtime","shortCorrection":"Set of class members stays fixed at runtime","concepts":["Class","Method","Field","Allocation"],"status":"public","spec":[{"id":"jls21","sections":["4.3.1","8.2","15.9"]}]},{"name":"AllClassesHaveDefaultConstructor","pl":"Java","shortDescription":"All classes automatically get a no-argument constructor","shortCorrection":"Only classes without constructor automatically get a no-argument constructor","concepts":["Class","Constructor"],"status":"draft","spec":[{"id":"jls21","sections":["8.8.9"]}]},{"name":"AnyClassException","pl":"Java","shortDescription":"Any class can be an exception class","shortCorrection":"Exceptions are subtypes of Throwable","concepts":["Exception","Class"],"status":"draft","spec":[{"id":"jls21","sections":["11.1.1"]}]},{"name":"ArithmeticPlusPrecedes","pl":"Java","shortDescription":"Addition has higher precedence than string concatenation","shortCorrection":"Addition and string concatenation have same precedence","concepts":["String","Expression","Operator","Precedence","Associativity"],"status":"public","spec":[{"id":"jls21","sections":["15.18"]}]},{"name":"ArrayAllocationWithoutNew","pl":"Java","shortDescription":"Arrays are created without the new keyword","shortCorrection":"All arrays are allocated on the heap with new","concepts":["Array","Allocation"],"status":"draft","spec":[{"id":"jls21","sections":["10.3","10.6","15.10.1"]}]},{"name":"ArrayAccessWithParentheses","pl":"Java","shortDescription":"Parentheses are used to access an element in an array","shortCorrection":"Square brackets are used to access an element in an array","concepts":["Array","Operator"],"status":"draft","spec":[{"id":"jls21","sections":["10.4"]}]},{"name":"ArrayBracketCountIsLength","pl":"Java","shortDescription":"The number of brackets in an array type or an array initializer corresponds to the length of the array","shortCorrection":"The number of brackets in an array type or an array initializer corresponds to the rank of the array","concepts":["Array","Allocation"],"status":"draft","spec":[{"id":"jls21","sections":["10.1","10.6"]}]},{"name":"ArrayElementTypeRepeats","pl":"Java","shortDescription":"The type of a multi-dimensional array is written as T[] T[] T[]","shortCorrection":"The type of a multi-dimensional array is written as T[][][]","concepts":["Array","Type"],"status":"draft","spec":[{"id":"jls21","sections":["10.1"]}]},{"name":"ArrayElementsUntyped","pl":"Java","shortDescription":"Elements of arrays are untyped","shortCorrection":"The type of an array specifies the type of the elements","concepts":["Array","Type"],"status":"draft","spec":[{"id":"jls21","sections":["10.1","10.5"]}]},{"name":"ArrayHasLengthMethod","pl":"Java","shortDescription":"To get the length of an array, one needs to call its length method","shortCorrection":"To get the length of an array, one needs to read its length field","concepts":["Array","Method","Field"],"status":"public","spec":[{"id":"jls21","sections":["10.7"]}]},{"name":"ArrayInitializerContentsInBrackets","pl":"Java","shortDescription":"Array initializers list the elements in square brackets","shortCorrection":"Array initializers list the elements in curly braces","concepts":["Array","Literal"],"status":"draft","spec":[{"id":"jls21","sections":["10.6"]}]},{"name":"ArrayLengthPartOfType","pl":"Java","shortDescription":"The length of an array is part of its type","shortCorrection":"The length of an array is not part of its type","concepts":["Array","Type"],"status":"draft","spec":[{"id":"jls21","sections":["10.1"]}]},{"name":"ArrayListIsArray","pl":"Java","shortDescription":"ArrayLists are arrays","shortCorrection":"ArrayLists and arrays are different things","concepts":["Array","Class"],"status":"public","spec":[{"id":"jls21","sections":["10.1"]}]},{"name":"ArrayRankIsLength","pl":"Java","shortDescription":"Array rank and array length are the same thing","shortCorrection":"Array rank and array length are different concepts","concepts":["Array"],"status":"draft","spec":[{"id":"jls21","sections":["10.1","10.7"]}]},{"name":"ArraysGrow","pl":"Java","shortDescription":"Arrays can grow dynamically","shortCorrection":"The length of an array is fixed and is determined at allocation","concepts":["Array","Allocation"],"status":"public","spec":[{"id":"jls21","sections":["10.3"]}]},{"name":"ArrayLengthCannotBeZero","pl":"Java","shortDescription":"An array cannot have a length of 0 elements","shortCorrection":"An array can have a length of 0 elements","concepts":["Array"],"status":"draft","spec":[{"id":"jls21","sections":["10.3","10.6"]}]},{"name":"AssignCompares","pl":"Java","shortDescription":"= compares two values","shortCorrection":"= assigns a value to a variable","concepts":["Assignment","Equality","Expression","Operator"],"status":"public","spec":[{"id":"jls21","sections":["15.26","15.21"]}]},{"name":"AssignmentCopiesObject","pl":"Java","shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference pointing to the object","concepts":["Assignment","Variable","Object","Reference"],"status":"public","spec":[{"id":"jls21","sections":["4.3.1","15.26"]}]},{"name":"AssignmentNotExpression","pl":"Java","shortDescription":"An assignment a=b is not an expression","shortCorrection":"An assignment a=b is an expression and thus produces a value","concepts":["Expression","Operator","Assignment"],"status":"public","spec":[{"id":"jls21","sections":["15.26"]}]},{"name":"BaseCaseNotNeeded","pl":"Java","shortDescription":"Recursive computations do not necessarily need a base case","shortCorrection":"Recursive computations need a base case to terminate","concepts":["Recursion","Method","Conditional","Call"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4"]}]},{"name":"BaseCaseSelfRecursive","pl":"Java","shortDescription":"The base case of a structural recursion consists of a recursive self-call","shortCorrection":"The base case of a structural recursion does not perform a recursive call","concepts":["Recursion","Method","Call"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4"]}]},{"name":"CallNotStaticallyChecked","pl":"Java","shortDescription":"A method invocation on a reference of a type that does not have that method won't compile","shortCorrection":"A method invocation on a reference of a type that does not have that method will compile","concepts":["Method","Call","Class","Subtyping"],"status":"public","spec":[{"id":"jls21","sections":["15.12"]}]},{"name":"CallOnPrimitive","pl":"Java","shortDescription":"One can invoke a method on primitive values","shortCorrection":"One cannot invoke methods on primitive values","concepts":["Method","Call","Primitive"],"status":"draft","spec":[{"id":"jls21","sections":["4.2","15.12"]}]},{"name":"CallRequiresVariable","pl":"Java","shortDescription":"One needs a variable to invoke a method","shortCorrection":"Methods can be invoked on expressions that evaluate to a suitable object","concepts":["Method","Call"],"status":"draft","spec":[{"id":"jls21","sections":["15.12"]}]},{"name":"CallWithoutFrame","pl":"Java","shortDescription":"A method invocation does not necessarily allocate a stack frame","shortCorrection":"Each method invocation allocates a new stack frame","concepts":["Method","Call","Stack"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4.5"]}]},{"name":"CallerFrameContainsCalleeFormal","pl":"Java","shortDescription":"Stack frame of caller includes variables for callee's formal parameters","shortCorrection":"Stack frame of caller does not include variables for callee's formal parameters","concepts":["Method","Call","Stack","Variable","Parameter"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4"]}]},{"name":"CannotChainMemberAccesses","pl":"Java","shortDescription":"Member accesses cannot be chained together","shortCorrection":"Member accesses can be chained together","concepts":["Method","Call","Field","Member","Expression","Operator"],"status":"public","spec":[{"id":"jls21","sections":["15.11","15.12"]}]},{"name":"CannotChainMemberToConstructor","pl":"Java","shortDescription":"Method calls or field accesses cannot be chained to a constructor invocation","shortCorrection":"Method calls or field accesses can be chained to a constructor invocation","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"status":"public","spec":[{"id":"jls21","sections":["15.11","15.12"]}]},{"name":"CatchAlwaysExecutes","pl":"Java","shortDescription":"Catch blocks always get executed","shortCorrection":"Catch blocks only get executed if an exception is thrown in the try block","concepts":["Exception","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.20.1"]}]},{"name":"CatchProvidesOptions","pl":"Java","shortDescription":"Only the part of a catch block necessary to fix the cause of an exception is executed","shortCorrection":"When an exception is caught, all statements in the corresponding catch block execute","concepts":["Exception","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.20.1","14.1","14.2"]}]},{"name":"ChainedMethodsNotCalledFromOutside","pl":"Java","shortDescription":"Chained methods are all called on the object at the beginning of the chain","shortCorrection":"Chained methods are called on the object that results from the previous call in the chain","concepts":["Method","Call","Expression","Object"],"status":"draft","spec":[{"id":"jls21","sections":["15.12"]}]},{"name":"ComparisonWithBooleanLiteral","pl":"Java","shortDescription":"To test whether an expression is true or false, one must compare it to true or to false","shortCorrection":"To test whether an expression is true or false, one can just use it","concepts":["Boolean","Expression","Operator","Equality"],"status":"public","spec":[{"id":"jls21","sections":["15.21.2","15","4.2.5"]}]},{"name":"CompositeExpressionsUntyped","pl":"Java","shortDescription":"Expressions that consist of multiple parts have no type","shortCorrection":"Expressions that consist of multiple parts have a type","concepts":["Type","Expression"],"status":"draft","spec":[{"id":"jls21","sections":["15.3"]}]},{"name":"CharNotNumeric","pl":"Java","shortDescription":"Char is not a numeric type","shortCorrection":"Char is a numeric type","concepts":["Number","String","Type"],"status":"public","spec":[{"id":"jls21","sections":["4.2.1"]}]},{"name":"ConcreteClassMustOverride","pl":"Java","shortDescription":"A concrete class needs to implement all abstract methods and override all concrete methods declared in its abstract superclasses","shortCorrection":"A concrete class does not necessarily need to override concrete methods declared in its abstract superclasses","concepts":["Class","Method","Inheritance"],"status":"draft","spec":[{"id":"jls13","sections":["8.1.1.1","8.4.3.1"]}]},{"name":"ArrayRankNotPartOfType","pl":"Java","shortDescription":"The rank of an array is not part of its type","shortCorrection":"The rank of an array is part of its type","concepts":["Array","Type"],"status":"draft","spec":[{"id":"jls21","sections":["10.1"]}]},{"name":"ConcreteClassOnlyImplementClassAbstract","pl":"Java","shortDescription":"A concrete class only needs to implement those abstract methods it inherits from abstract superclasses","shortCorrection":"A concrete class needs to implement both the abstract methods it inherits from abstract superclasses and those declared in the interfaces it implements","concepts":["Class","Method","Subtyping","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.5"]}]},{"name":"ConcreteClassOnlyImplementDirectAbstract","pl":"Java","shortDescription":"A concrete class only needs to implement abstract methods declared in its direct supertypes","shortCorrection":"A concrete class needs to implement all abstract methods declared in its supertypes, both direct and indirect","concepts":["Class","Method","Subtyping","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["8.4.3.1","8.4.8"]}]},{"name":"ConcreteClassOnlyImplementInterfaceAbstract","pl":"Java","shortDescription":"A concrete class only needs to implement those abstract methods it inherits from interfaces","shortCorrection":"A concrete class needs to implement both the abstract methods it inherits from interfaces and those declared in the abstract class it extends","concepts":["Class","Method","Subtyping","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.4"]}]},{"name":"ConditionalIsSequence","pl":"Java","shortDescription":"If-else is equivalent to sequence of two ifs","shortCorrection":"If-else can behave differently from sequence of two ifs","concepts":["Conditional","ControlFlow"],"status":"public","spec":[{"id":"jls21","sections":["14.9"]}]},{"name":"ConstructorAllocates","pl":"Java","shortDescription":"The constructor allocates the object","shortCorrection":"The constructor does not allocate the object, it just initializes it","concepts":["Allocation","Constructor","Call"],"status":"public","spec":[{"id":"jls21","sections":["15.9"]}]},{"name":"ConstructorParameterIsField","pl":"Java","shortDescription":"Formal constructor parameters are equivalent to instance variables","shortCorrection":"Formal constructor parameters are completely separate from instance variables","concepts":["Constructor","Parameter","Field"],"status":"draft","spec":[{"id":"jls21","sections":["8.3","8.8","8.8.1"]}]},{"name":"ConstructorReturnsObject","pl":"Java","shortDescription":"Constructors need to return objects","shortCorrection":"Constructors cannot return anything","concepts":["Allocation","Constructor","Call","Return"],"status":"public","spec":[{"id":"jls21","sections":["14.17"]}]},{"name":"ConstructorWithoutNew","pl":"Java","shortDescription":"One can write the constructor name, without new, to instantiate a class","shortCorrection":"The constructor name needs to come after the keyword new to instantiate a class","concepts":["Constructor","Call","Allocation"],"status":"draft","spec":[{"id":"jls21","sections":["12.5","15.9"]}]},{"name":"ControlledLocalAccess","pl":"Java","shortDescription":"One can control access to local variables using access modifiers","shortCorrection":"One cannot control access to local variables","concepts":["Variable","Scope","Lifetime","AccessModifier"],"status":"public","spec":[{"id":"jls21","sections":["14.4"]}]},{"name":"ElsIf","pl":"Java","shortDescription":"There is an elsif keyword for multi-way conditional statements","shortCorrection":"There is no special keyword for multi-way conditional statements","concepts":["Conditional","ControlFlow"],"status":"draft","spec":[{"id":"jls13","sections":["14.9"]}]},{"name":"ElseAlwaysExecutes","pl":"Java","shortDescription":"The else branch of an if-else statement always executes","shortCorrection":"The else branch of an if-else statement only executes if the condition evaluates to false","concepts":["Conditional","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.9.2"]}]},{"name":"EqualityOperatorComparesObjectsValues","pl":"Java","shortDescription":"o==p compares the objects referred to by variables o and p","shortCorrection":"o==p compares the references stored in the variables o and p","concepts":["Equality","Reference","Object","Value","Operator","Expression"],"status":"public","spec":[{"id":"jls21","sections":["15.21"]}]},{"name":"DeferredReturn","pl":"Java","shortDescription":"A return statement in the middle of a method doesn't return immediately","shortCorrection":"A return statement immediately returns from the method","concepts":["Return","ControlFlow","Method","Call"],"status":"public","spec":[{"id":"jls21","sections":["14.17"]}]},{"name":"EqualsComparesReferences","pl":"Java","shortDescription":"o.equals(p) compares the references stored in the variables o and p","shortCorrection":"o.equals(p) compares the objects referred to by variables o and p","concepts":["Equality","Reference","Object","Value","Method","Expression"],"status":"public","spec":[{"id":"jls21","sections":["4.3.2","15.21"]}]},{"name":"EvaluationResultsArePrinted","pl":"Java","shortDescription":"Evaluating an expression means outputting its result","shortCorrection":"Evaluating an expression produces a value, but does not output it","concepts":["Evaluation","Output"],"status":"draft","spec":[{"id":"jls21","sections":["15.1"]}]},{"name":"ExceptionRoot","pl":"Java","shortDescription":"Exception is the top-most exception class","shortCorrection":"Throwable is the top-most exception class","concepts":["Exception","Subtyping"],"status":"draft","spec":[{"id":"jls21","sections":["11.1.1"]}]},{"name":"ExpressionAssigns","pl":"Java","shortDescription":"An expression that reads a variable also updates its value after the evaluation","shortCorrection":"A variable is only written using an assignment","concepts":["Expression","Assignment","Variable"],"status":"draft","spec":[{"id":"jls21","sections":["6.5.6.1","15.26"]}]},{"name":"ExpressionsDynamicallyTyped","pl":"Java","shortDescription":"One has to evaluate an expression to determine its type","shortCorrection":"The type of expressions is determined, without evaluation, at compile time","concepts":["Evaluation","Expression","Value","Type"],"status":"draft","spec":[{"id":"jls21","sections":["15.3"]}]},{"name":"FinalReferenceImpliesImmutability","pl":"Java","shortDescription":"An object referred to by a final variable is an immutable object","shortCorrection":"An object referred to by a final variable can be a mutable object","concepts":["Mutability","Reference"],"status":"public","spec":[{"id":"jls21","sections":["4.12.4"]}]},{"name":"ForEachIteratesOverIndices","pl":"Java","shortDescription":"An enhanced for loop iterates over the indices of an array or a collection","shortCorrection":"An enhanced for loop iterates over the elements of an array or a collection","concepts":["Loop","Variable","Array"],"status":"draft","spec":[{"id":"jls21","sections":["14.14.2"]}]},{"name":"ForEachTraversesRecursiveStructure","pl":"Java","shortDescription":"For-each loops know how to traverse any recursive data structure","shortCorrection":"For-each loops only know how to traverse arrays and Iterables","concepts":["Loop","Recursion"],"status":"draft","spec":[{"id":"jls21","sections":["14.14.2"]}]},{"name":"ForEachVariableIsElement","pl":"Java","shortDescription":"One can assign to the variable of an enhanced for statement to store a value in the corresponding array or collection element","shortCorrection":"The variable of an enhanced for statement contains a copy of the value of the corresponding array or collection element","concepts":["Loop","Variable","Array"],"status":"draft","spec":[{"id":"jls21","sections":["14.14.2"]}]},{"name":"ForIsConditional","pl":"Java","shortDescription":"The body of a for statement executes at most once","shortCorrection":"The body of a for statement executes repeatedly, as long as the condition holds","concepts":["Conditional","Loop","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.14"]}]},{"name":"ForVariableScopeBeyondLoop","pl":"Java","shortDescription":"The scope of variables declared in a for loop header extends beyond the loop","shortCorrection":"The scope of variables declared in a for loop header is limited to the loop","concepts":["Loop","Variable","Scope"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.3","14.4","6.3"]}]},{"name":"FrameIsClassInstance","pl":"Java","shortDescription":"A stack frame is the same as an instance of a class","shortCorrection":"Stack frames and class instances both hold variables, but they are different concepts","concepts":["Stack","Object","Call"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4"]}]},{"name":"IfIsLoop","pl":"Java","shortDescription":"The body of an if statement executes repeatedly, as long as the condition holds","shortCorrection":"The body of an if statement executes at most once","concepts":["Conditional","Loop","ControlFlow"],"status":"public","spec":[{"id":"jls21","sections":["14.9"]}]},{"name":"IfRequiresElse","pl":"Java","shortDescription":"Every if statement requires an else","shortCorrection":"If statements do not necessarily require an else","concepts":["Conditional","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.9.1"]}]},{"name":"ImplicitInterfaceImplementation","pl":"Java","shortDescription":"Java implicitly produces implementations of any methods a class inherits from the interfaces it implements","shortCorrection":"Java does not implicitly produce implementations of any methods a class inherits from the interfaces it implements","concepts":["Class","Method","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.5","8.4.8"]}]},{"name":"IntegerDivisionToRational","pl":"Java","shortDescription":"Dividing two integers can produce a rational number","shortCorrection":"Dividing two integers always produces an integer","concepts":["Number","Type"],"status":"draft","spec":[{"id":"jls21","sections":["15.17.2","4.2.2"]}]},{"name":"InterfaceExtendClass","pl":"Java","shortDescription":"An interface can extend a class","shortCorrection":"An interface cannot extend a class","concepts":["Class","Subtyping","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["9.1.3"]}]},{"name":"LargeIntegerLong","pl":"Java","shortDescription":"Large integer numbers have type long","shortCorrection":"Integer numbers without L or l suffix that are too large for an int are illegal","concepts":["Literal","Number","Type","Expression"],"status":"public","spec":[{"id":"jls21","sections":["3.10.1"]}]},{"name":"LiteralNoExpression","pl":"Java","shortDescription":"A literal is not an expression","shortCorrection":"Even an individual literal is an expression","concepts":["Literal","Expression"],"status":"draft","spec":[{"id":"jls21","sections":["15.8.1"]}]},{"name":"LiteralString","pl":"Java","shortDescription":"When passing a literal string as argument to a method, no quotes are needed","shortCorrection":"String literals always must be surrounded by quotes","concepts":["Literal","String","Argument"],"status":"draft","spec":[{"id":"jls21","sections":["3.10.5","15.12"]}]},{"name":"LocalVariablesAutoInitialized","pl":"Java","shortDescription":"Local variables are automatically initialized","shortCorrection":"Local variables must be initialized explicitly","concepts":["Variable","Value","Assignment"],"status":"public","spec":[{"id":"jls21","sections":["14.4","14.4.2","16"]}]},{"name":"LoopBodyScopeImpliesLoopLifetime","pl":"Java","shortDescription":"Lifetime of variables declared in a loop body extends across all loop iterations","shortCorrection":"Lifetime of variables declared in a loop body is limited to one loop iteration","concepts":["Loop","Variable","Lifetime","Scope"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.3","14.4","6.3"]}]},{"name":"LoopTerminatingCondition","pl":"Java","shortDescription":"For and while loops end when the condition becomes true","shortCorrection":"For and while loops end when the condition becomes false","concepts":["Loop","Conditional","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.12","14.14"]}]},{"name":"MapToBooleanWithIf","pl":"Java","shortDescription":"To map a boolean expression to a boolean, an if statement is necessary","shortCorrection":"To map a boolean expression to a boolean, one can just use it","concepts":["Conditional","Statement","Boolean"],"status":"public","spec":[{"id":"jls21","sections":["14.9.2","15","4.2.5"]}]},{"name":"MethodAsField","pl":"Java","shortDescription":"Each object contains its own special fields for all of its methods","shortCorrection":"Each object contains a special field referring to its class, and the class knows about its methods","concepts":["Method","Field","Object","Class"],"status":"draft","spec":[{"id":"jls21","sections":["15.9.4"]}]},{"name":"MethodWithoutReturnType","pl":"Java","shortDescription":"A method declaration does not need to include a return type","shortCorrection":"A method declaration must include a return type","concepts":["Method","Type"],"status":"draft","spec":[{"id":"jls21","sections":["8.4"]}]},{"name":"MapToBooleanWithConditionalOperator","pl":"Java","shortDescription":"To map a boolean expression to a boolean, a conditional operator is necessary","shortCorrection":"To map a boolean expression to a boolean, one can just use it","concepts":["Conditional","Expression","Operator","Boolean"],"status":"public","spec":[{"id":"jls21","sections":["15.25","15","4.2.5"]}]},{"name":"MethodsWithoutClass","pl":"Java","shortDescription":"Methods can be defined outside a class","shortCorrection":"Methods must be defined inside a class","concepts":["Method","Class"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.7","8.4"]}]},{"name":"MultiValueVariable","pl":"Java","shortDescription":"A variable can contain more than one value","shortCorrection":"A variable can contain only one value at a time","concepts":["Variable","Value"],"status":"draft","spec":[{"id":"jls21","sections":["4.12"]}]},{"name":"MultidimensionalArray","pl":"Java","shortDescription":"A multi-dimensional array is one single array object","shortCorrection":"A multi-dimensional is a structure of nested arrays","concepts":["Array"],"status":"draft","spec":[{"id":"jls21","sections":["15.10.2"]}]},{"name":"MultiReferenceVariable","pl":"Java","shortDescription":"A reference variable can point to multiple objects","shortCorrection":"A reference variable can point to only one object at a time","concepts":["Reference","Variable","Object"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.2"]}]},{"name":"MultipleSuperclasses","pl":"Java","shortDescription":"A class can have multiple superclasses","shortCorrection":"A class can have only one direct superclass","concepts":["Class","Subtyping"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.4"]}]},{"name":"ImmutableRequiresFinalParameters","pl":"Java","shortDescription":"Immutable classes need final constructor/method parameters","shortCorrection":"Immutable classes can have constructor/method parameters that are not final","concepts":["Mutability","Class","Constructor","Method","Parameter"],"status":"draft","spec":[{"id":"jls21","sections":["8.4.1","4.12.4"]}]},{"name":"MustInitializeFieldInConstructor","pl":"Java","shortDescription":"Constructors must assign values to all fields","shortCorrection":"Constructors do not need to assign values to all fields","concepts":["Assignment","Constructor","Field","Value","Variable"],"status":"public","spec":[{"id":"jls21","sections":["8.3.2","16"]}]},{"name":"NamedTypeParameter","pl":"Java","shortDescription":"To instantiate a generic type, for each type parameter one has to specify both the name and the type","shortCorrection":"To instantiate a generic type, for each type parameter one only needs to specify the type","concepts":["Type","Parameter","Name"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.2","15.9"]}]},{"name":"NestedObjectsImplyNestedClasses","pl":"Java","shortDescription":"If objects are part of a containment hierarchy, their classes are nested, too","shortCorrection":"Classes are independent of object containment","concepts":["Class","Object"],"status":"draft","spec":[{"id":"jls21","sections":["8.5"]}]},{"name":"NestedPackages","pl":"Java","shortDescription":"Packages can contain other packages which have access to members of the containing package","shortCorrection":"Sub-packages are independent of their parent packages and do not have special access rights","concepts":["Member"],"status":"draft","spec":[{"id":"jls21","sections":["7.1"]}]},{"name":"NoAtomicExpression","pl":"Java","shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","concepts":["Expression","Operator","Literal","Variable"],"status":"public","spec":[{"id":"jls21","sections":["15.8"]}]},{"name":"NoCallOnStringLiteral","pl":"Java","shortDescription":"One cannot invoke methods on String literals","shortCorrection":"One can invoke methods on String literals","concepts":["Method","Call","String","Literal"],"status":"draft","spec":[{"id":"jls21","sections":["15.12","3.10.5"]}]},{"name":"NoCastIfSameSize","pl":"Java","shortDescription":"If a variable is at least as big (bit-width) as a value, then no cast is needed to a assign the value to the variable","shortCorrection":"A variable being at least as big (bit-width) as a value may not be sufficient to avoid a cast when assigning the value to the variable","concepts":["Variable","Value","Number","Type"],"status":"draft","spec":[{"id":"jls21","sections":["5.1"]}]},{"name":"NoEmptyConstructor","pl":"Java","shortDescription":"A constructor must do something","shortCorrection":"A constructor's body can be empty","concepts":["Constructor"],"status":"public","spec":[{"id":"jls21","sections":["12.5"]}]},{"name":"NoFieldlessObjects","pl":"Java","shortDescription":"Objects without instance variables can't exist","shortCorrection":"Objects can have any number of instance variables, including zero","concepts":["Object","Field"],"status":"draft","spec":[{"id":"jls21","sections":["8.1.7"]}]},{"name":"NoFieldInheritance","pl":"Java","shortDescription":"An object contains only the fields declared in its class","shortCorrection":"An object contains the fields declared in its class and all its superclasses","concepts":["Object","Class","Field"],"status":"draft","spec":[{"id":"jls21","sections":["8.2"]}]},{"name":"NoFloatLiterals","pl":"Java","shortDescription":"There are no float literals","shortCorrection":"An F or f suffix can turn a number into a float literal","concepts":["Literal","Number","Type"],"status":"public","spec":[{"id":"jls21","sections":["3.10.2"]}]},{"name":"NoImplicitWidening","pl":"Java","shortDescription":"Smaller types are never automatically converted into bigger ones without an explicit cast","shortCorrection":"Smaller types can be automatically converted into bigger ones even without an explicit cast","concepts":["Type"],"status":"draft","spec":[{"id":"jls21","sections":["5.1"]}]},{"name":"NoInsideMethodCallInConstructor","pl":"Java","shortDescription":"It is foirbidden to call other methods on the same object while inside its constructor","shortCorrection":"It is allow to call other methods on the same object while inside its constructor","concepts":["Method","Call","Constructor","Object"],"status":"draft","spec":[{"id":"jls21","sections":["8.8"]}]},{"name":"NoCharEscape","pl":"Java","shortDescription":"\\ is a normal character in char and String literals","shortCorrection":"\\ is an escape character in char and String literals","concepts":["String","Literal"],"status":"draft","spec":[{"id":"jls21","sections":["3.10.7"]}]},{"name":"NoJaggedArrays","pl":"Java","shortDescription":"Multi-dimensional arrays have a rectangular shape","shortCorrection":"Multi-dimensional arrays can have a jagged shape","concepts":["Array"],"status":"draft","spec":[{"id":"jls21","sections":["10.2","15.10.1","10.6"]}]},{"name":"NoLocalVariables","pl":"Java","shortDescription":"There are no local variables","shortCorrection":"Methods can have local variables","concepts":["Variable","Stack"],"status":"draft","spec":[{"id":"jls21","sections":["14.4"]}]},{"name":"NoLongLiterals","pl":"Java","shortDescription":"There are no long literals","shortCorrection":"An L or l suffix can turn a number into a long literal","concepts":["Literal","Number","Type"],"status":"public","spec":[{"id":"jls21","sections":["3.10.1"]}]},{"name":"NoMethodInheritance","pl":"Java","shortDescription":"Subclasses inherit fields but not methods","shortCorrection":"Subclasses inherit both fields and methods","concepts":["Inheritance","Field","Method","Class"],"status":"draft","spec":[{"id":"jls21","sections":["8.2","8.4.8"]}]},{"name":"NoReservedWords","pl":"Java","shortDescription":"Every sequence of letters and digits starting with a letter can be used as an identifier","shortCorrection":"Some character sequences are reserved for use as keywords and cannot be used as identifiers","concepts":["Name"],"status":"public","spec":[{"id":"jls21","sections":["3.9"]}]},{"name":"NoShortCircuit","pl":"Java","shortDescription":"&& and || always evaluate both operands","shortCorrection":"&& and || evaluate their right operand only if absolutely necessary","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"status":"public","spec":[{"id":"jls21","sections":["15.23","15.24"]}]},{"name":"NoSingleLogicAnd","pl":"Java","shortDescription":"& is only a bitwise AND","shortCorrection":"& for boolean operands is a logical AND","concepts":["Operator","Boolean"],"status":"public","spec":[{"id":"jls21","sections":["15.22.2","15.23"]}]},{"name":"NoStringToString","pl":"Java","shortDescription":"One cannot invoke toString() on a String","shortCorrection":"One can invoke toString() on a String","concepts":["String","Method","Call"],"status":"draft","spec":[{"id":"jls21","sections":["4.3.1","4.3.2","4.3.3"]}]},{"name":"NullIsObject","pl":"Java","shortDescription":"null is an object","shortCorrection":"null is a reference pointing to no object","concepts":["Reference","Object","Null","Literal","Value"],"status":"public","spec":[{"id":"jls21","sections":["3.10.8","4.3.1"]}]},{"name":"NullPointerExceptionCompileTime","pl":"Java","shortDescription":"NullPointerExceptions are detected at compile time","shortCorrection":"NullPointerExceptions are detected at runtime","concepts":["Exception"],"status":"draft","spec":[{"id":"jls21","sections":["11.2","11.3"]}]},{"name":"NumericToBooleanCoercion","pl":"Java","shortDescription":"Numeric types can be coerced to boolean","shortCorrection":"Numeric types cannot be coerced to boolean","concepts":["Number","Type","Boolean"],"status":"draft","spec":[{"id":"jls21","sections":["4.2.5","5.1"]}]},{"name":"ObjectsMustBeNamed","pl":"Java","shortDescription":"A variable is needed to instantiate an object","shortCorrection":"Objects have no name and can exist without a variable referring to them","concepts":["Allocation","Constructor","Call","Expression","Name"],"status":"public","spec":[{"id":"jls21","sections":["14.8"]}]},{"name":"OnlyInnermostArrayElements","pl":"Java","shortDescription":"Only the elements of the innermost array of a multi-dimensional array are accessible","shortCorrection":"Also the elements of outer arrays of a multi-dimensional array are accessible","concepts":["Array"],"status":"draft","spec":[{"id":"jls21","sections":["10.4","10.3"]}]},{"name":"OutOfBoundsElementsAreNull","pl":"Java","shortDescription":"Out-of-bounds array elements are null","shortCorrection":"Out-of-bounds array elements cannot be accessed","concepts":["Array","Null"],"status":"draft","spec":[{"id":"jls21","sections":["10.4"]}]},{"name":"OutsideInMethodNesting","pl":"Java","shortDescription":"Nested method calls are invoked outside in","shortCorrection":"Nested method calls are invoked inside out","concepts":["Method","Call","Expression","Function","Composition"],"status":"public","spec":[{"id":"jls21","sections":["15.12"]}]},{"name":"ParenthesesOnlyIfArgument","pl":"Java","shortDescription":"() are optional for method calls without arguments","shortCorrection":"() are mandatory even for method calls without arguments","concepts":["Method","Call","Expression"],"status":"public","spec":[{"id":"jls21","sections":["15.12","15.8.5"]}]},{"name":"PrimitiveIsObject","pl":"Java","shortDescription":"Primitive values are heap objects","shortCorrection":"Primitive values are not objects","concepts":["Primitive","Value","Object"],"status":"draft","spec":[{"id":"jls21","sections":["4.2","4.12.1"]}]},{"name":"PreIncrementBeforeLoop","pl":"Java","shortDescription":"Pre-increment in update part of for loop means increment before loop body","shortCorrection":"Pre-increment in update part of for loop means same as pre-increment anywhere else","concepts":["Operator","Loop","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["14.14.1.2","15.15.1","15.14.2"]}]},{"name":"PrimitiveTypeParameter","pl":"Java","shortDescription":"Type parameters of generic types can be instantiated with primitive types","shortCorrection":"Type parameters of generic types need to be instantiated with reference types","concepts":["Type","Parameter","Primitive"],"status":"draft","spec":[{"id":"jls21","sections":["4.5.1"]}]},{"name":"PrimitiveVariablesDynamicallyTyped","pl":"Java","shortDescription":"The type of a primitive variable depends on its value","shortCorrection":"The type of a primitive variable is fixed and does not depend on its value","concepts":["Type","Value"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.1"]}]},{"name":"PrivateAccessibleInSubclass","pl":"Java","shortDescription":"Private members of a superclass are accessible from a subclass","shortCorrection":"Private members of a superclass are not accessible from a subclass","concepts":["Member","Field","Method","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["6.6","6.6.1","8.2"]}]},{"name":"PrivateFieldsImplyImmutability","pl":"Java","shortDescription":"A class where all fields are private is immutable","shortCorrection":"A class where all fields are private can still be mutable","concepts":["Mutability","Class","Field","AccessModifier"],"status":"draft","spec":[{"id":"jls21","sections":["8.3.1.2","4.12.4"]}]},{"name":"PrivateFromOtherInstance","pl":"Java","shortDescription":"An object cannot access private members of other objects of the same class","shortCorrection":"An object can access private members of all other objects of the same class","concepts":["AccessModifier","Member"],"status":"public","spec":[{"id":"jls21","sections":["6.6.1"]}]},{"name":"PrivateFromStatic","pl":"Java","shortDescription":"Static methods cannot access private members of instances of same class","shortCorrection":"Static methods can access private members of instances of same class","concepts":["AccessModifier","Member","Static"],"status":"public","spec":[{"id":"jls21","sections":["6.6.1"]}]},{"name":"PrivateMeansFinal","pl":"Java","shortDescription":"A private field cannot be changed","shortCorrection":"Even a private field can be mutable","concepts":["Mutability","Field","AccessModifier"],"status":"draft","spec":[{"id":"jls21","sections":["8.3.1.2","6.6.1"]}]},{"name":"RationalLiterals","pl":"Java","shortDescription":"Rational fractions are literals","shortCorrection":"Rational fractions are divisions of two integer literals","concepts":["Number","Literal"],"status":"draft","spec":[{"id":"jls21","sections":["3.10.1","15.17.2"]}]},{"name":"RecursiveCallSiteNoReturn","pl":"Java","shortDescription":"Tail-recursive call sites of non-void methods need no return statement","shortCorrection":"In non-void methods, even tail-recursive call sites need a return statement","concepts":["Recursion","Call"],"status":"draft","spec":[{"id":"jls21","sections":["8.4.5","14.17"]}]},{"name":"RecursiveActivationsShareFrame","pl":"Java","shortDescription":"Recursive calls of a method share a stack frame","shortCorrection":"Each recursive call of a method gets its own stack frame","concepts":["Recursion","Stack"],"status":"public","spec":[{"id":"jls21","sections":["15.2","8.4"]}]},{"name":"RecursiveMethodImpliesRecursiveType","pl":"Java","shortDescription":"A class with a recursive method represents part of a recursive data structure","shortCorrection":"A class having a recursive method does not imply that it is part of a recursive data structure","concepts":["Recursion","Method","Type"],"status":"public","spec":[{"id":"jls21","sections":["15.2","8.4","8.1","8.3"]}]},{"name":"RecursiveMethodNeedsIfElse","pl":"Java","shortDescription":"A recursive method needs to contain an if-else statement","shortCorrection":"A recursive method does not necessarily need to contain an if-else statement","concepts":["Recursion","Method","Conditional","ControlFlow"],"status":"public","spec":[{"id":"jls21","sections":["15.2","8.4"]}]},{"name":"ReferenceIntoStack","pl":"Java","shortDescription":"References can point into the stack","shortCorrection":"References can only point into the heap","concepts":["Reference","Stack"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.2","4.3.1"]}]},{"name":"ReferenceToBooleanCoercion","pl":"Java","shortDescription":"Every reference type can be coerced to boolean","shortCorrection":"Not every reference type can be coerced to boolean","concepts":["Reference","Type","Boolean"],"status":"draft","spec":[{"id":"jls21","sections":["4.2.5","5.1","5.1.8"]}]},{"name":"ReferenceToIntegerConversion","pl":"Java","shortDescription":"One can cast between references and ints","shortCorrection":"One cannot cast between references and ints","concepts":["Reference","Type","Number"],"status":"draft","spec":[{"id":"jls21","sections":["4.2.1","5.1","5.1.8"]}]},{"name":"ReferenceToVariable","pl":"Java","shortDescription":"References can point to variables","shortCorrection":"References can only point to heap objects","concepts":["Reference","Variable"],"status":"public","spec":[{"id":"jls21","sections":["4.12.2","4.3.1"]}]},{"name":"ReferringToRecursiveStructureMakesRecursive","pl":"Java","shortDescription":"A class referring to a recursive data structure is (indirectly) part of that recursion as well","shortCorrection":"If a class refers to a recursive data structure, it is not necessarily part of that recursion","concepts":["Class","Recursion"],"status":"draft","spec":[{"id":"jls21","sections":["8.2","8.3"]}]},{"name":"ReturnUnwindsMultipleFrames","pl":"Java","shortDescription":"A return statement can unwind multiple call stack frames","shortCorrection":"A return statement pops exactly one call stack frame","concepts":["Call","Return","Stack","Recursion"],"status":"public","spec":[{"id":"jls21","sections":["14.17"]}]},{"name":"RightToLeftChaining","pl":"Java","shortDescription":"Chained accesses are invoked from right to left","shortCorrection":"Chained accesses are invoked from left to right","concepts":["Method","Call","Field","Member","Expression","Operator","Associativity"],"status":"public","spec":[{"id":"jls21","sections":["15.11","15.12"]}]},{"name":"ReturnCall","pl":"Java","shortDescription":"Return statements need () around the return value","shortCorrection":"Return statements do not need () around the return value","concepts":["Return","Method","Call"],"status":"public","spec":[{"id":"jls21","sections":["14.17"]}]},{"name":"RuntimeExceptionChecked","pl":"Java","shortDescription":"RuntimeExceptions are checked exceptions","shortCorrection":"RuntimeExceptions are unchecked exceptions","concepts":["Exception","Subtyping"],"status":"draft","spec":[{"id":"jls21","sections":["11.1"]}]},{"name":"SingleQuoteString","pl":"Java","shortDescription":"String literals can be in single quotes","shortCorrection":"String literals must be in double quotes","concepts":["String","Literal"],"status":"draft","spec":[{"id":"jls21","sections":["3.10.5"]}]},{"name":"StackTraceIsCallHistory","pl":"Java","shortDescription":"A stack trace is the sequence of previously called methods","shortCorrection":"A stack trace only includes the currently active methods","concepts":["Stack","Method","Call"],"status":"draft","spec":[{"id":"jls21","sections":["15.12.4.5"]}]},{"name":"StaticDispatch","pl":"Java","shortDescription":"The method to be called is determined by the static type","shortCorrection":"The method to be called is determined by the dynamic type","concepts":["Inheritance","Method","Call","Subtyping"],"status":"draft","spec":[{"id":"jls21","sections":["15.12","15.12.2"]}]},{"name":"StaticCallPolymorphic","pl":"Java","shortDescription":"A static method call is dispatched polymorphically at runtime based on the argument types","shortCorrection":"A static method call is dispatched based on the declared types of the arguments","concepts":["Method","Call","Polymorphism","Parameter","Type"],"status":"draft","spec":[{"id":"jls21","sections":["15.12","15.12.2"]}]},{"name":"StringLiteralNoObject","pl":"Java","shortDescription":"One needs to call the String constructor to get a String object from a literal","shortCorrection":"A String literal represents a String object and can be treated as such","concepts":["Literal","String"],"status":"public","spec":[{"id":"jls21","sections":["3.10.5"]}]},{"name":"StringPlusStringifiesExpression","pl":"Java","shortDescription":"String concatenation stringifies non-String operand expressions","shortCorrection":"String concatenation evaluates non-String operand expressions and casts value to String","concepts":["String","Expression","Operator"],"status":"public","spec":[{"id":"jls21","sections":["15.18.1","5.1.11"]}]},{"name":"SubtypeCompatibleWithSupertype","pl":"Java","shortDescription":"A variable of a subtype can reference an object of a supertype","shortCorrection":"A variable of a subtype cannot reference an object of a supertype","concepts":["Subtyping","Type","Inheritance","Reference"],"status":"draft","spec":[{"id":"jls21","sections":["4.10","4.12.2"]}]},{"name":"StringRepetitionOperator","pl":"Java","shortDescription":"The multiplication operator can repeat a String a number of times","shortCorrection":"The multiplication operator does not accept a String and a number","concepts":["String","Number","Repetition"],"status":"draft","spec":[{"id":"jls21","sections":["15.17"]}]},{"name":"SuperAlwaysHasParentheses","pl":"Java","shortDescription":"To call a method on a superclass, parentheses are needed after the keyword super","shortCorrection":"To call a method on a superclass, it is wrong to write parentheses after the keyword super","concepts":["Call","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["15.12"]}]},{"name":"SuperNotFirstStatement","pl":"Java","shortDescription":"super() can be called anywhere in the constructor of a subclass","shortCorrection":"super() must be called in the first statement in the constructor of a subclass","concepts":["Inheritance","Call"],"status":"draft","spec":[{"id":"jls21","sections":["8.8.7"]}]},{"name":"SuperclassObjectAllocated","pl":"Java","shortDescription":"When instantiating an object of a subclass, an object of a superclass is also allocated","shortCorrection":"When instantiating an object of a subclass, just that object is allocated","concepts":["Allocation","Class","Object","Inheritance"],"status":"draft","spec":[{"id":"jls21","sections":["15.9.4"]}]},{"name":"SupertypeIncompatibleWithSubtype","pl":"Java","shortDescription":"A variable of a supertype cannot reference an object of a subtype","shortCorrection":"A variable of a supertype can reference an object of a subtype","concepts":["Inheritance","Subtyping","Type","Reference"],"status":"draft","spec":[{"id":"jls21","sections":["4.10","4.12.2"]}]},{"name":"TargetTyping","pl":"Java","shortDescription":"The type of a numerical expression depends on the type expected by the surrounding context","shortCorrection":"The type of a numerical expression is determined by the expression","concepts":["Type","Number","Expression"],"status":"draft","spec":[{"id":"jls21","sections":["15.3"]}]},{"name":"ThisAsField","pl":"Java","shortDescription":"this is a special field in the object","shortCorrection":"this is a special local variable in the stack frame","concepts":["Field","Variable","Reference","Object","Self"],"status":"draft","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"ThisAssignable","pl":"Java","shortDescription":"One can assign to this","shortCorrection":"One cannot assign to this","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"status":"public","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"StringLengthField","pl":"Java","shortDescription":"One can know the length of a String object by accessing its length field","shortCorrection":"One can know the length of a String object by calling its length method","concepts":["String","Field","Method"],"status":"draft","spec":[{"id":"jls21","sections":["10.3","10.9","4.3.3"]}]},{"name":"ThisCanBeNull","pl":"Java","shortDescription":"this can be null","shortCorrection":"this is never null","concepts":["Null","Reference","Self"],"status":"public","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"ThisExistsInStaticMethod","pl":"Java","shortDescription":"this is a local variable, also in static methods","shortCorrection":"this does not exist in static methods","concepts":["Variable","Reference","Object","Static","Method","Self"],"status":"public","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"ThisInConstructorIsNull","pl":"Java","shortDescription":"In a constructor, this is null","shortCorrection":"In a constructor, this is never null","concepts":["Constructor","Null","Reference","Self"],"status":"draft","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"ThisNoExpression","pl":"Java","shortDescription":"The name this is not an expression","shortCorrection":"Even the name this on its own is an expression","concepts":["Expression","Self"],"status":"public","spec":[{"id":"jls21","sections":["15.8.3"]}]},{"name":"ToStringPrints","pl":"Java","shortDescription":"Invoking toString() prints something","shortCorrection":"Invoking toString() does not produce any output","concepts":["Method","String","Output","Evaluation"],"status":"draft","spec":[{"id":"jls21","sections":["4.3.1","15.1"]}]},{"name":"TryCatchMandatory","pl":"Java","shortDescription":"When a piece of code can throw an exception, it must be surrounded with a try/catch block","shortCorrection":"When a piece of code can throw an exception, it is optional to surround it with a try/catch block","concepts":["Exception","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["11.2"]}]},{"name":"TryFinishes","pl":"Java","shortDescription":"Exceptions get thrown at the end of the try block","shortCorrection":"Exceptions get thrown immediately when they occur","concepts":["Exception","ControlFlow"],"status":"draft","spec":[{"id":"jls21","sections":["11.3"]}]},{"name":"UndeclaredVariables","pl":"Java","shortDescription":"Variables can be used even without being declared beforehand","shortCorrection":"Variables must be declared before they are used","concepts":["Variable"],"status":"draft","spec":[{"id":"jls21","sections":["4.12.3"]}]},{"name":"UnqualifiedNamesMustDiffer","pl":"Java","shortDescription":"The unqualified names of different classes must be different","shortCorrection":"Classes in different packages can have the same unqualified name","concepts":["Name","Class","Scope"],"status":"draft","spec":[{"id":"jls21","sections":["7.1"]}]},{"name":"UntypedVariables","pl":"Java","shortDescription":"Variable declarations don't need a type","shortCorrection":"Variable declarations need a type","concepts":["Variable","Type"],"status":"draft","spec":[{"id":"jls21","sections":["14.4","14.4.1","8.3"]},{"id":"jls9","sections":["14.4","14.4.1","8.3"]}]},{"name":"UseOfSelfTypeImpliesRecursiveType","pl":"Java","shortDescription":"If a class has a method that has a local variable, parameter, or return value with the class as its type, the class is a recursive type","shortCorrection":"A class can have methods with a local variable, parameter, or return value with the class as its type without being a recursive type","concepts":["Class","Method","Variable","Parameter","Return","Value","Type","Recursion"],"status":"draft","spec":[{"id":"jls21","sections":["8.3"]}]},{"name":"VariablesHoldExpressions","pl":"Java","shortDescription":"= stores an expression in a variable","shortCorrection":"= evaluates an expression and stores its value in a variable","concepts":["Variable","Expression","Assignment"],"status":"public","spec":[{"id":"jls21","sections":["4.12"]}]},{"name":"VariablesHoldObjects","pl":"Java","shortDescription":"A variable of a reference type contains a whole object","shortCorrection":"A variable of a reference type contains a reference to an object","concepts":["Variable","Object","Reference"],"status":"public","spec":[{"id":"jls21","sections":["4.1","4.3.1","4.12.2"]}]},{"name":"VoidMethodNotRecursive","pl":"Java","shortDescription":"A method with void return type can't be recursive","shortCorrection":"A method with void return type can be recursive","concepts":["Method","Type","Recursion"],"status":"draft","spec":[{"id":"jls21","sections":["8.4.5"]}]},{"name":"VoidMethodReturnsValue","pl":"Java","shortDescription":"A method with void return type can return a value","shortCorrection":"A method with void return type cannot return a value","concepts":["Method","Type","Return","Value"],"status":"draft","spec":[{"id":"jls21","sections":["8.4.5"]}]},{"name":"ZeroDigitsCompress","pl":"Java","shortDescription":"In integer numbers, decimal digits with value `0` take less storage than decimal digits with other values","shortCorrection":"In integer numbers, all decimal digits take the same amount of storage","concepts":["Number"],"status":"draft","spec":[{"id":"jls13","sections":["3.10.1"]}]},{"name":"AccessingInexistentPropertyError","pl":"JavaScript","shortDescription":"Accessing a non existent property on an object produces an error","shortCorrection":"Accessing a non existent property on an object evaluates to undefined","concepts":["Exception","Field","Member","Object","Undefined"],"status":"draft","spec":[{"id":"ecma11","sections":["9.1"]}]},{"name":"ArrowFunctionNoImpliedReturn","pl":"JavaScript","shortDescription":"Even when an arrow function consists just of an expression, the return keyword must be explicitly written","shortCorrection":"When an arrow function consists just of an expression, the return keyword is implied","concepts":["Return","Expression","Function"],"status":"draft","spec":[{"id":"ecma11","sections":["14.2"]}]},{"name":"ArrowFunctionRequiresFunctionKeyword","pl":"JavaScript","shortDescription":"Arrow functions also require the keyword 'function'","shortCorrection":"Arrow functions do not require the keyword 'function'","concepts":["Function","Expression"],"status":"draft","spec":[{"id":"ecma11","sections":["14.2"]}]},{"name":"AssignmentCopiesObject","pl":"JavaScript","shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference pointing to the object","concepts":["Assignment","Variable","Object","Reference"],"status":"public","spec":[{"id":"ecma11","sections":["12.15.4"]}]},{"name":"CallbackParametersInCaller","pl":"JavaScript","shortDescription":"Parameters of a callback function may be written as parameters of the caller function","shortCorrection":"A function that expects a callback has that callback function as a parameter","concepts":["Argument","Parameter","Function","Value","Call"],"status":"draft","spec":[{"id":"ecma11","sections":["12.3.6"]}]},{"name":"CharType","pl":"JavaScript","shortDescription":"A single character is of type char","shortCorrection":"A single character is of type string","concepts":["String","Type"],"status":"draft","spec":[{"id":"ecma11","sections":["11.8.4"]}]},{"name":"ClassDefinesType","pl":"JavaScript","shortDescription":"The type of an object is equivalent to the type defined by its class definition","shortCorrection":"A class definition does not define a type; all objects have type object","concepts":["Class","Type"],"status":"public","spec":[{"id":"ecma11","sections":["4.2.1","6.1","12.5.5","12.10.4","14.6"]}]},{"name":"ConstDeclarationCanBeLeftUninitialized","pl":"JavaScript","shortDescription":"Declarations of constants do not need to be immediately initialized","shortCorrection":"Declarations of constants need to be immediately initialized","concepts":["Assignment","Variable"],"status":"draft","spec":[{"id":"ecma11","sections":["13.3.1"]}]},{"name":"ConstReferenceImpliesImmutability","pl":"JavaScript","shortDescription":"An object referred to by a const variable is an immutable object","shortCorrection":"An object referred to by a const variable can be a mutable object","concepts":["Mutability","Reference"],"status":"public","spec":[{"id":"ecma11","sections":["13.3.1"]}]},{"name":"EqualityOperatorComparesObjectsValues","pl":"JavaScript","shortDescription":"The equality operator compares two objects' values","shortCorrection":"The equality operator compares two objects' references","concepts":["Equality","Object","Operator","Reference","Value"],"status":"draft","spec":[{"id":"ecma11","sections":["12.11"]}]},{"name":"EqualityOperatorComparesOnlyTypes","pl":"JavaScript","shortDescription":"The equality operator '==' compares only the types of the operands","shortCorrection":"The equality operator '==' compares only the values of the operands","concepts":["Operator","Equality","Type","Value"],"status":"draft","spec":[{"id":"ecma11","sections":["12.11"]}]},{"name":"FunctionAsValueWithParentheses","pl":"JavaScript","shortDescription":"To use a function as a value, one needs to have parentheses after its name","shortCorrection":"To use a function as a value, one just needs to write its name","concepts":["Function","Value","Call"],"status":"draft","spec":[{"id":"ecma11","sections":["12.1"]}]},{"name":"FunctionOverloading","pl":"JavaScript","shortDescription":"It is possible to create multiple functions with the same name but with different signatures","shortCorrection":"It not is possible to create multiple functions with the same name but with different signatures","concepts":["Function","Argument","Parameter"],"status":"draft","spec":[{"id":"ecma11","sections":["5.1","7.3.18","9.4.4","14.1"]}]},{"name":"FunctionsCannotBeImmediatelyInvoked","pl":"JavaScript","shortDescription":"Functions cannot be called in the expression in which they are defined","shortCorrection":"Functions can be immediately called in the expression in which they are defined","concepts":["Function","Call","Scope"],"status":"draft","spec":[{"id":"ecma11","sections":["14.1","14.2"]}]},{"name":"FunctionsMustBeNamed","pl":"JavaScript","shortDescription":"Every function definition requires an associated name","shortCorrection":"One can define a function without associating a name to it","concepts":["Function","Name","Scope"],"status":"draft","spec":[{"id":"ecma11","sections":["14.1","14.2","19.2.4","19.2.4.2"]}]},{"name":"ConditionalOperatorNotExpression","pl":"JavaScript","shortDescription":"The conditional operator is not an expression","shortCorrection":"The conditional operator is not an expression","concepts":["Expression","Operator","Conditional","ControlFlow"],"status":"draft","spec":[{"id":"ecma11","sections":["12.14"]}]},{"name":"IdentifierAsStringInBracketNotation","pl":"JavaScript","shortDescription":"An identifier used to access a property with the bracket notation is treated as a string","shortCorrection":"An identifier used to access a property with the bracket notation is firstly evaluated","concepts":["Expression","String","Field","Object"],"status":"draft","spec":[{"id":"ecma11","sections":["12.3.2"]}]},{"name":"MandatoryAssignment","pl":"JavaScript","shortDescription":"An expression must be assigned to have a valid statement","shortCorrection":"An expression alone, without an assignment, is already a valid statement","concepts":["Assignment","Expression","Statement"],"status":"draft","spec":[{"id":"ecma11","sections":["13.5"]}]},{"name":"MapInPlace","pl":"JavaScript","shortDescription":"Map modifies the elements of the array on which it operates in place","shortCorrection":"Map returns a new array populated with the results of the callback function","concepts":["Array","Return"],"status":"draft","spec":[{"id":"ecma11","sections":["22.1.3.18"]}]},{"name":"NoAtomicExpression","pl":"JavaScript","shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","concepts":["Expression","Operator","Literal","Variable"],"status":"public","spec":[{"id":"ecma11","sections":["11.8"]}]},{"name":"NoBracketNotationForObjects","pl":"JavaScript","shortDescription":"Square brackets cannot be used to access properties of an object","shortCorrection":"Square brackets can be used to access properties of an object","concepts":["Object","Field"],"status":"draft","spec":[{"id":"ecma11","sections":["12.3.2"]}]},{"name":"NoFunctionCallsChaining","pl":"JavaScript","shortDescription":"It is not allowed to chain function calls","shortCorrection":"Multiple function calls can be chained together","concepts":["Expression","Call","Function","Precedence"],"status":"draft","spec":[{"id":"ecma11","sections":["12.3.2"]}]},{"name":"NoGlobalObject","pl":"JavaScript","shortDescription":"There isn't a global object","shortCorrection":"There is always a global object","concepts":["Object","Scope"],"status":"draft","spec":[{"id":"ecma11","sections":["12.2.2","18"]}]},{"name":"NoReturnValue","pl":"JavaScript","shortDescription":"Functions without return statements return no value at all","shortCorrection":"Functions without return statements return undefined","concepts":["Undefined","Return","Value"],"status":"draft","spec":[{"id":"ecma11","sections":["12.3.6"]}]},{"name":"NullAndUndefinedAreTheSame","pl":"JavaScript","shortDescription":"The values null and undefined are the same","shortCorrection":"null and undefined are two distinct values","concepts":["Type","Value","Equality","Null","Undefined"],"status":"draft","spec":[{"id":"ecma11","sections":["4.3.10","4.3.11","4.3.12","4.3.13","12.5.5"]}]},{"name":"NullIsObject","pl":"JavaScript","shortDescription":"null is an object","shortCorrection":"null is a reference pointing to no object","concepts":["Null","Object","Reference","Value","Literal"],"status":"public","spec":[{"id":"ecma11","sections":["4.3.13"]}]},{"name":"NumberOfParametersMatchArguments","pl":"JavaScript","shortDescription":"Functions must be called with the same number of arguments as defined in their signature","shortCorrection":"Functions can be called with a different number of arguments as defined in their signature","concepts":["Function","Call","Argument","Parameter"],"status":"draft","spec":[{"id":"ecma11","sections":["9.4.4","14.1"]}]},{"name":"ObjectAsParameterIsCopied","pl":"JavaScript","shortDescription":"Objects are passed by value","shortCorrection":"Objects are passed by reference","concepts":["Argument","Parameter","Object","Reference"],"status":"draft","spec":[{"id":"ecma11","sections":["14.1"]}]},{"name":"PrototypesAreClasses","pl":"JavaScript","shortDescription":"JavaScript is based on a class-based object model","shortCorrection":"JavaScript is based on a prototype-based object model","concepts":["Prototype","Class"],"status":"draft","spec":[{"id":"ecma11","sections":["4.2.1","4.3.5","14.6"]}]},{"name":"StringRepetitionOperator","pl":"JavaScript","shortDescription":"One can repeat a String by multiplying it with a number","shortCorrection":"One cannot repeat a String by multiplying it with a number","concepts":["String","Number","Repetition"],"status":"draft","spec":[{"id":"ecma11","sections":["12.7"]}]},{"name":"ThisAssignable","pl":"JavaScript","shortDescription":"One can assign to this","shortCorrection":"One cannot assign to this","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"status":"public","spec":[{"id":"ecma11","sections":["8.1","12.2.2","19.2.3.1","19.2.3.2","19.2.3.3"]}]},{"name":"TypeofArrayIsArray","pl":"JavaScript","shortDescription":"The typeof operator applied on an array returns 'array'","shortCorrection":"The typeof operator applied on an array returns 'object'","concepts":["Array","Type"],"status":"draft","spec":[{"id":"ecma11","sections":["12.5.5"]}]},{"name":"TypeofNullIsNull","pl":"JavaScript","shortDescription":"The value null is of type 'null'","shortCorrection":"The value null is of type 'object'","concepts":["Value","Type"],"status":"draft","spec":[{"id":"ecma11","sections":["4.3.10","4.3.11","4.3.12","4.3.13","12.5.5"]}]},{"name":"AssignCompares","pl":"Python","shortDescription":"= compares two values","shortCorrection":"= assigns a value to a variable","concepts":["Assignment","Equality","Expression","Operator"],"status":"public","spec":[{"id":"plr3.13","sections":["lib-dict"]},{"id":"plr3.13","sections":["8.1"]},{"id":"plr3.13","sections":["6.10"]}]},{"name":"AssignmentCopiesObject","pl":"Python","shortDescription":"Assignment copies the object","shortCorrection":"Assignment copies the reference to the object","concepts":["Allocation","Assignment","Object","Reference","Value","Variable"],"status":"public","spec":[{"id":"plr3.13","sections":["7.2"]},{"id":"plr3.13","sections":["3.0"]}]},{"name":"CannotChainAttributeAccesses","pl":"Python","shortDescription":"Attribute accesses cannot be chained together","shortCorrection":"Attribute accesses can be chained together","concepts":["Method","Call","Field","Member","Expression","Operator"],"status":"public","spec":[{"id":"plr3.13","sections":["6.3.1","6.3.4"]}]},{"name":"ComparisonWithBoolLiteral","pl":"Python","shortDescription":"To test whether an expression is True or False, one must compare it to True or to False","shortCorrection":"To test whether an expression is True or False, one can just use it","concepts":["Boolean","Equality","Evaluation","Expression","Literal","Operator"],"status":"public","spec":[{"id":"plr3.13","sections":["6.0"]}]},{"name":"DeferredReturn","pl":"Python","shortDescription":"A return statement in the middle of a function doesn't return immediately","shortCorrection":"A return statement immediately returns from the function","concepts":["Return","ControlFlow","Function","Call"],"status":"public","spec":[{"id":"plr3.13","sections":["7.6"]}]},{"name":"ConditionalIsSequence","pl":"Python","shortDescription":"If-else is equivalent to sequence of two ifs","shortCorrection":"If-else can behave differently from sequence of two ifs","concepts":["Conditional","ControlFlow"],"status":"public","spec":[{"id":"plr3.13","sections":["8.1"]}]},{"name":"IfIsLoop","pl":"Python","shortDescription":"The body of an if-statement executes repeatedly, as long as the condition holds","shortCorrection":"The body of an if-statement executes at most once","concepts":["Conditional","Loop","ControlFlow"],"status":"public","spec":[{"id":"plr3.13","sections":["7.0"]}]},{"name":"InitCreates","pl":"Python","shortDescription":"__init__ must create a new object","shortCorrection":"__init__ does not create the object, it just initializes it","concepts":["Allocation","Call","Constructor"],"status":"public","spec":[{"id":"plr3.13","sections":["3.3.1"]}]},{"name":"InitReturnsObject","pl":"Python","shortDescription":"__init__ needs to return an object","shortCorrection":"__init__ cannot return values other than None","concepts":["Allocation","Constructor","Call","Return"],"status":"public","spec":[{"id":"plr3.13","sections":["3.3.1"]}]},{"name":"MapToBooleanWithIf","pl":"Python","shortDescription":"To map a boolean expression to a bool, an if statement is necessary","shortCorrection":"To map a boolean expression to a bool, one can just use it","concepts":["Conditional","Statement","Boolean","Evaluation"],"status":"public","spec":[{"id":"plr3.13","sections":["6.10"]}]},{"name":"MapToBooleanWithTernaryOperator","pl":"Python","shortDescription":"To map a boolean expression to a bool, a ternary conditional operator is necessary","shortCorrection":"To map a boolean expression to a bool, one can just use it","concepts":["Conditional","Expression","Operator","Boolean"],"status":"public","spec":[{"id":"plr3.13","sections":["6.10","6.13"]}]},{"name":"MultipleValuesReturn","pl":"Python","shortDescription":"Functions can return multiple values","shortCorrection":"Functions can only return one value","concepts":["Value","Return","Function"],"status":"public","spec":[{"id":"plr3.13","sections":["6.15","7.6"]}]},{"name":"NoAtomicExpression","pl":"Python","shortDescription":"Expressions must consist of more than one piece","shortCorrection":"A single piece, like a literal or name, also is an expression","concepts":["Expression","Operator","Literal","Variable"],"status":"public","spec":[{"id":"plr3.13","sections":["2.4"]}]},{"name":"NoReservedWords","pl":"Python","shortDescription":"Every sequence of letters and digits starting with a letter or an underscore can be used as an identifier","shortCorrection":"Some character sequences are reserved for use as keywords and cannot be used as identifiers","concepts":["Name"],"status":"public","spec":[{"id":"plr3.13","sections":["2.3.1"]}]},{"name":"NoSequenceRepetition","pl":"Python","shortDescription":"There is no operator that repeats sequences","shortCorrection":"The * operator can be used to repeat sequences","concepts":["String","Sequence","Number","Repetition"],"status":"draft","spec":[{"id":"plr3.13","sections":["6.7"]}]},{"name":"NoShortCircuit","pl":"Python","shortDescription":"and/or always evaluate both operands","shortCorrection":"and/or evaluate their right operand only if absolutely necessary","concepts":["Expression","Evaluation","Operator","Boolean","ControlFlow"],"status":"public","spec":[{"id":"plr3.13","sections":["lib-booleanoperations"]}]},{"name":"NoSingleLogicAnd","pl":"Python","shortDescription":"& is only a bitwise AND","shortCorrection":"& for boolean operands is a logical AND","concepts":["Boolean","Expression","Operator"],"status":"public","spec":[{"id":"plr3.13","sections":["3.2.4.1","6.9"]}]},{"name":"ObjectsMustBeNamed","pl":"Python","shortDescription":"A variable is needed to instantiate an object","shortCorrection":"Objects have no name and can exist without a variable referring to them","concepts":["Allocation","Call","Expression","Constructor","Name","Object"],"status":"public","spec":[{"id":"plr3.13","sections":["3.0","6.3.4"]}]},{"name":"NoEmptyInit","pl":"Python","shortDescription":"__init__ must do something","shortCorrection":"The body of __init__ can be empty","concepts":["Constructor"],"status":"public","spec":[{"id":"plr3.13","sections":["3.3.1"]}]},{"name":"ParenthesesOnlyIfArgument","pl":"Python","shortDescription":"() are optional for function calls without arguments","shortCorrection":"() are mandatory even for function calls without arguments","concepts":["Function","Call","Expression"],"status":"public","spec":[{"id":"plr3.13","sections":["6.3.4"]}]},{"name":"PlusConcatenatesNumbers","pl":"Python","shortDescription":"The plus operator can concatenate strings and numbers","shortCorrection":"The plus operator cannot concatenate strings and numbers","concepts":["String","Sequence","Number","Expression","Operator"],"status":"draft","spec":[{"id":"plr3.13","sections":["6.7"]}]},{"name":"OutsideInFunctionNesting","pl":"Python","shortDescription":"Nested function calls are invoked outside in","shortCorrection":"Nested function calls are invoked inside out","concepts":["Call","Composition","ControlFlow","Expression","Function"],"status":"public","spec":[{"id":"plr3.13","sections":["6.16"]}]},{"name":"RecursiveFunctionNeedsIfElse","pl":"Python","shortDescription":"A recursive function needs to contain an if-else statement","shortCorrection":"A recursive function does not necessarily need to contain an if-else statement","concepts":["Conditional","ControlFlow","Recursion"],"status":"public","spec":[{"id":"plr3.13","sections":["6.3.4","8.1"]}]},{"name":"ReturnCall","pl":"Python","shortDescription":"Return statements need () around the return value","shortCorrection":"Return statements do not need () around the return value","concepts":["Call","Evaluation","Function","Return"],"status":"public","spec":[{"id":"plr3.13","sections":["7.6"]}]},{"name":"ReturnUnwindsMultipleFrames","pl":"Python","shortDescription":"A return statement can unwind multiple call stack frames","shortCorrection":"A return statement pops exactly one call stack frame","concepts":["Call","Recursion","Return","Stack"],"status":"public","spec":[{"id":"plr3.13","sections":["7.6"]}]},{"name":"RightToLeftChaining","pl":"Python","shortDescription":"Chained accesses are invoked from right to left","shortCorrection":"Chained accesses are invoked from left to right","concepts":["Associativity","Call","ControlFlow","Evaluation","Expression","Field","Method"],"status":"public","spec":[{"id":"plr3.13","sections":["6.16"]}]},{"name":"SelfAssignable","pl":"Python","shortDescription":"Reassigning self changes the object on which a method is called","shortCorrection":"Reassigning self does not change the object on which a method is called","concepts":["Variable","Reference","Assignment","Object","Mutability","Self"],"status":"public","spec":[{"id":"plr3.13","sections":["3.2.8.2"]}]},{"name":"SelfNoExpression","pl":"Python","shortDescription":"The name self is not an expression","shortCorrection":"Even the name self on its own is an expression","concepts":["Expression","Self"],"status":"public","spec":[{"id":"plr3.13","sections":["3.2"]},{"id":"plr3.13","sections":["6.0"]}]},{"name":"StringLiteralNoObject","pl":"Python","shortDescription":"One needs to call str to instantiate a str object from a string literal","shortCorrection":"A string literal represents a str object and can be treated as such","concepts":["Expression","Literal","Name","String"],"status":"public","spec":[{"id":"plr3.13","sections":["3.2.5.1","lib-str"]}]},{"name":"VariablesHoldExpressions","pl":"Python","shortDescription":"= stores an expression: it stores a reference to the expression in a variable","shortCorrection":"= evaluates an expression and stores a reference to its value in a variable","concepts":["Variable","Expression","Assignment","Value"],"status":"public","spec":[{"id":"plr3.13","sections":["3.1"]},{"id":"plr3.13","sections":["6.16"]}]},{"name":"VariablesHoldObjects","pl":"Python","shortDescription":"A variable contains a whole object","shortCorrection":"A variable contains a reference to an object","concepts":["Variable","Object","Reference","Value"],"status":"public","spec":[{"id":"plr3.13","sections":["3.1"]}]},{"name":"BaseCaseNotNeeded","pl":"Scratch","shortDescription":"Recursive computations do not necessarily need a base case","shortCorrection":"Recursive computations need a base case to terminate","concepts":["Recursion","Conditional","Call"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-My_Blocks"]}]},{"name":"ConditionalIsSequence","pl":"Scratch","shortDescription":"If-then-else block is equivalent to sequence of two if-then blocks","shortCorrection":"If-then-else block can behave differently from sequence of two if-then blocks","concepts":["Conditional","ControlFlow"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-If_()_Then_(block)","wiki-If_()_Then,_Else_(block)","wiki-Not_()_(block)"]}]},{"name":"CompareBooleanToConstant","pl":"Scratch","shortDescription":"To test whether an expression evaluates to true or false, one must compare it to a constant","shortCorrection":"To test whether an expression evaluates to true or false, one can just use it","concepts":["Boolean","Expression","Operator","Equality"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-()_=_()_(block)","wiki-Boolean_Block","wiki-Casting"]}]},{"name":"ElseAlwaysExecutes","pl":"Scratch","shortDescription":"The else branch of an if-then-else block always executes","shortCorrection":"The else branch of an if-then-else block only executes if the condition evaluates to false","concepts":["Conditional","ControlFlow"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-If_()_Then,_Else_(block)","wiki-Stack_Block"]}]},{"name":"EqualityOperatorComparesListIdentities","pl":"Scratch","shortDescription":"(list a) = (list b) compares the identities of list a and list b","shortCorrection":"(list a) = (list b) compares the contents of list a and list b","concepts":["Equality","Reference","Object","Value","Expression"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-()_=_()_(block)","wiki-List","wiki-Casting"]}]},{"name":"EqualityOperatorComparesOnlyTypes","pl":"Scratch","shortDescription":"() = () compares only the types of its operands","shortCorrection":"() = () compares the values of its operands","concepts":["Operator","Equality","Type","Value"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-()_=_()_(block)","wiki-Casting"]}]},{"name":"ListLengthCannotBeZero","pl":"Scratch","shortDescription":"A list cannot have a length of 0 items","shortCorrection":"A list can have a length of 0 items","concepts":["Array"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-Length_of_()_(List_block)","wiki-Delete_All_of_()_(block)","wiki-Delete_()_of_()_(block)","wiki-List_Blocks","wiki-List"]}]},{"name":"ListsHomogeneous","pl":"Scratch","shortDescription":"All items in a list must have the same type","shortCorrection":"A list can contain items of different types","concepts":["Array","Type"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-Add_()_to_()_(block)","wiki-List_Blocks","wiki-List","wiki-Item","wiki-Casting"]}]},{"name":"ExpressionAssigns","pl":"Scratch","shortDescription":"An expression that reads a variable also updates its value after the evaluation","shortCorrection":"A variable is only written using an assignment","concepts":["Expression","Assignment","Variable"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-Variables_Blocks_(subcategory)","wiki-()_(Variables block)","wiki-Set_()_to_()_(block)","wiki-Operators_Blocks"]}]},{"name":"MissingElseTerminates","pl":"Scratch","shortDescription":"Blocks following an if without else will not execute if the condition is false","shortCorrection":"Blocks following an if without else will execute even if the condition is false","concepts":["Conditional","ControlFlow"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-If_()_Then_(block)","wiki-Stack_Block"]}]},{"name":"RepeatDistributes","pl":"Scratch","shortDescription":"Each block in a loop is repeated individually","shortCorrection":"The whole sequence of blocks in a loop is repeated","concepts":["Loop","ControlFlow"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-Repeat_()_(block)","wiki-Repeat_Until_()_(block)"]}]},{"name":"ResetStateEachLoopIteration","pl":"Scratch","shortDescription":"The computation of all loop iterations starts from the state before the loop","shortCorrection":"The computation of a loop iteration starts from the state that is based on everything that happened before, including prior iterations of the loop","concepts":["Loop","ControlFlow"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-Repeat_()_(block)","wiki-Repeat_Until_()_(block)"]}]},{"name":"ResetStateEachProgramExecution","pl":"Scratch","shortDescription":"Running a Scratch program first resets the state of the world and then executes the program","shortCorrection":"Running a Scratch program executes the program starting with the world in its current state","concepts":["Variable","Lifetime"],"status":"public","spec":[{"id":"scratch3.0","sections":["wiki-When_Green_Flag_Clicked_(block)"]}]},{"name":"CannotChainAttributeToObjectInstantiation","pl":"Python","shortDescription":"Method calls, and attribute accesses in general, cannot be chained to a constructor invocation.","shortCorrection":"Method calls, and attribute accesses in general, can be chained to a constructor invocation.","concepts":["Method","Field","Member","Constructor","Call","Expression","Operator"],"status":"public","spec":[{"id":"plr3.13","sections":["6.3.1","6.3.4"]}]}]}